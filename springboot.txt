
	
1.spring boot:	简介:
		SpringBoot 来简化Spring应用开发,约定大于配置,去繁从简,just run就能创建一个独立的,产品级的应用
		
		背景:
			j2ee 笨重的开发,繁琐的配置,低下的开发效率,复杂的部署流程,第三方技术集成难度大
			
		解决:
			spring全家桶时代
			spring boot ->j2ee一站式解决方案
			spring cloud ->分布式整体解决方案
		优点：
			优点：
			-快速创建独立运行的Spring项目以及与主流框架集成 
			-使用嵌入式的Servlet容器，应用无需打成WAR包 
			-starters自动依赖与版本控制 
			-大量的自动配置，简化开发，也可修改默认值 
			-无需配置XML ,无代码生成，开箱即用 
			-准生产环境的运行时应用监控 
			-与云计算的天然集成
			
			
			总结：
				简化spring应用开发的一个框架
				整个Spring技术栈的一个大整合
				j2ee开发的一站式解决方案
				

2.微服务

	2014 martin fowler
	
	微服务:架构风格
	
	一个应用应该是一组小型服务的组合:可以通过http的方式进行沟通;
	
	单体应用: ALL IN ONE

	每一个功能元素都是一个可以独立替换和独立升级的软件单元
	
	详细参照微服务文档
	
	环境统一约定
	
		jdk1.8  springboot 1.7及以上
		maven 3.x
		intellij idea 2017
		spring boot 1.5.9.release
		
		
	maven设置:

		
		给maven的settions.xml加上
		
			<profile>
				<id>jdk-1.8</id>
				<activate>
					<activeByDefault>true</activeByDefault>
					<jdk>1.8</jdk>
				</activate>
				<properties>
					<maven.compiler.source>1.8</maven.compiler.source>
					<maven.compiler.target>1.8</maven.compiler.target>
					<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>			
				</properties>
			</profile>
			
	idea设置:
		configure->settiong->build->build Tool -> maven -> 选择maven目录 同时勾选两个override  选择自己的配置文件settings.xml加上
		
	
	
	4.spring boot helloworld:
	
		一个功能:
			一个浏览器发送hello 请求,服务器接受请求并进行处理,响应hello world字符串
			
		1.创建maven工程(jar)
		
			1.new project
			2.选择右边边框的maven选项 第一次选择sdk -> jdk的安装路径->create
			
		2.导入spring-boot相关依赖
		
		3.编写主程序 ;作用启动spring boot 程序
			
			main 方法 快捷键 p s v m 
			
			 /**
			 * Created by Administrator on 2019-03-18.
			 * @SpringBootApplication:来标注一个主程序类,说明这是一个spring boot 应用
			 *
			 *
			 */
			@SpringBootApplication
			public class HelloWorldMainApplication {

				public static void main(String[] args) {

					//spring应用启动起来
					SpringApplication.run( HelloWorldMainApplication.class ,args );
				}
			}
			
		4.编写相应的Controller Service
			/**
			 * Created by Administrator on 2019-03-18.
			 */
			@Controller
			public class HelloController {

				@ResponseBody
				@RequestMapping("/hello")
				public  String hello() {

					return "Hello World";
				}
			}
		
		5.运行主程序测试
		
		6.简化部署工作
			
			如何运行maven:
				点击idea左下角的方块 
				右面出现选择 maven
				选择maven 的lifecycle
			
			导入spring boot 的mavne插件
			
			<build>
				<plugins>
					<!-- 可以将应用打包成一个可执行的jar包;-->
					<plugin>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-maven-plugin</artifactId>
					</plugin>
				</plugins>
			</build>
			
			将这个应用打成jar包,直接使用java -jar 的命令进行执行
			
	
	
		细节分析:
			pom 文件：
			
			1.父项目
				<!-- 继承父包 -->
				<parent>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-parent</artifactId>
					<version>1.5.9.RELEASE</version>
				</parent>
				
				它的父项目
				
				<parent>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-dependencies</artifactId>
					<version>1.5.9.RELEASE</version>
					<relativePath>../../spring-boot-dependencies</relativePath>
				</parent>
			
				它来真正管理spring boot 应用中所有的依赖版本
			
			spring boot的版本仲裁中心
				
				以后我们导入依赖默认是不需要写版本的;(没有在dependencies管理的依赖自然需要写版本号)
				
			2.启动器   导入的依赖:
				     <dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-web</artifactId>
						<version>1.5.9.RELEASE</version>
					</dependency>
				
					spring-boot-starter-web;
					
						spring-boot-starter:spring boot场景启动器;帮我们导入了web模块正常运行的所依赖的组件
						
					spring boot 将所有的功能场景都抽取出来,做成一个个的starters(启动器),只需要在项目中引用这些starter
					相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景启动器
					
			
		主程序类,主入口类:
			
				/**
				 * Created by Administrator on 2019-03-18.
				 * @SpringBootApplication:来标注一个主程序类,说明这是一个spring boot 应用
				 *
				 *
				 */
				@SpringBootApplication
				public class HelloWorldMainApplication {

					public static void main(String[] args) {

						//spring应用启动起来
						SpringApplication.run( HelloWorldMainApplication.class ,args );
					}
				}

			@SpringBootApplication spring boot 应用标注在某个类上说明这个类时SpringBoot的主配置类,Spring boot 就应该
			运行这个类的main方法来启动Springboot应用
			
			@Target({ElementType.TYPE})
			@Retention(RetentionPolicy.RUNTIME)
			@Documented
			@Inherited
			@SpringBootConfiguration
			@EnableAutoConfiguration
			@ComponentScan(
				excludeFilters = {        @Filter(
						type = FilterType.CUSTOM,
						classes = {TypeExcludeFilter.class}
					),         @Filter(
						type = FilterType.CUSTOM,
						classes = {AutoConfigurationExcludeFilter.class}
					)}
			)
			public @interface SpringBootApplication {
			
			
			@SpringBootConfiguration :Spring boot 配置类
				标注在某个类上,表示这是一个Spring boot 的配置类
				
				@Configuration 配置类上标注这个注解;
				
					配置类----配置文件;配置类也是容器中的一个组件 @Component
				
			@EnableAutoConfiguration:开启自动配置功能
					
					以前需要配置的东西,Spring boot 帮我们自动配置，@EnableAutoConfiguration告诉Spring boot 自动配置功能
					
					这样自动配置才能生效;
					
					@Target({ElementType.TYPE})
					@Retention(RetentionPolicy.RUNTIME)
					@Documented
					@Inherited
					@AutoConfigurationPackage
					@Import({EnableAutoConfigurationImportSelector.class})
					public @interface EnableAutoConfiguration {
						String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

						Class<?>[] exclude() default {};

						String[] excludeName() default {};
					}
					
					@AutoConfigurationPackage：自动配置包
					
						@Target({ElementType.TYPE})
						@Retention(RetentionPolicy.RUNTIME)
						@Documented
						@Inherited
						@Import({Registrar.class})
						public @interface AutoConfigurationPackage {
						
						}
						
					  AutoConfigurationPackages.register
						将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件扫描到Spring容器中
						
					@Import({EnableAutoConfigurationImportSelector.class})
						给容器中导入组件?
						
						EnableAutoConfigurationImportSelector  导入哪些组件的选择器;
						
						将所有需要导入的组件以全类名的方式返回;这些组件就会全部添加到容器中
						
						会给容器中导入非常多的自动配置类(xxxAutoConfiguration):就是给容器中导入这个场景需要的所有组件
						并配置好这些组件;
						
						有了自动配置类,免去了我们手动编写配置注入功能组件等的工作
						
						 SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
							   EnableAutoConfiguration.class; this.beanClassLoader;
							   
							  从类路径下 "META-INF/spring.factories"中获取 EnableAutoConfiguration 指定的值，
							  将这些值作为自动配置导入到容器中,自动配置类就生效了,帮我们进行自动配置工作;以前我们需要自己
							  配置的东西,自动配置类都帮我们；	
						j2ee的整体解决方案和自动配置都在C:\Users\Administrator\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\1.5.9.RELEASE\spring-boot-autoconfigure-1.5.9.RELEASE.jar!\org\springframework\boot\autoconfigure	  
							  
						
						
	6.使用Spring Initializer 快速创建Spring Boot 项目:

		IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot 项目
		
			New Project -> Spring Initializer -> 更改包名 ——>选择我们需要的模块——>向导会联网创建Spring Boot项目
			
			
			导入mavne依赖 点击右侧的maven刷新按钮 就可以重新导入
			
			默认生成的Spring Boot 项目:
			
				1.主程序已经生成好了,我们只需要编写自己的业务逻辑

				2.配置文件夹中resources文件夹中目录结构
						static ：保存所有的静态文件;js css images
						templates:保存所有的模板页面;(spring boot 默认是jar包的方式使用嵌入式的Tomcat默认是不支持jsp页面的
						);可以使用模板引擎(freemarker,thymeleaf);
						
						application.properties:Spring Boot 应用的配置文件:可以修改一些默认配置 比如服务器端口号等
							  
							  
							  
					 
Spring Boot的配置:
	1.配置文件：
		Spring Boot 使用一个全局配置文件,配置文件名字是固定的:
			application.properties
			application.yml
			
		配置文件放在src/main/resources/目录或者类路径/config 下
		
		yml是yaml(YAML  isn't Markup Language)语言文件,以数据为中心,比json,xml等更适合做配置文件
		http://www.yaml.org/参考语法规范
		
		作用:全局配置文件可以对一些默认配置进行更改
		
		SpringBoot 在底层都给我们配置好了
		
		YAML A  Markup Language：是一个标记语言
		YAML YAML  isn't Markup Language :不是一个标记语言
		
		标记语言:
			以前的配置文件;大都使用的是 xxxx.xml文件;
			以数据为中心,比json,xml等更适合做配置文件;
			
			YAML:
				server:
					port: 8081
			XML:
				<server>
					<port>8081</port>
				</server>
				
			YAML:配置实例

				server:
					port: 8081
					
					
		YAML基本语法：
		
				key:(空格)value 表示一对键值对 空格必须有
			以空格的缩进来控制层级关系;只要是左对齐的一列数据,都是同一层级的
			
			server:
				port: 8081
				path: /hello
				
			属性和值是大小写敏感的
			
		2.值的写法
			字面量: 普通的值(数字,字符串,布尔)
				k：v
				字符串默认不用加上单引号或者双引号
				""：双引号  不会字符串里面的转义特殊字符,特殊字符会作为本身想表示的意思
					name:"zhansan\n lisi" 输出 zhansan 换行 lisi
				''：单引号;会转义特殊字符,特殊字符最终只是一个普通的字符串输出
					name:"zhansan\n lisi" 输出 zhansan \n lisi
			对象(属性和值) Map(属性和值)(键值对):
				k：v 在下一行来写对象的属性和值的关系,注意缩进
				对象还是k: v的方式
				friends: 
					lastName: zhansan
					age: 20
				
				行内写法:
				
				friends: {key: v,key: v}
			
			数组(List,Set):
			
				用-值表示数组中的一个元素;
				
				pets: 
					- cat 
					- dog
					- pig 
					
				行内写法:
					pets: [cat,dog,pig]
					
			
			Alt + insert 键生成getter setter			
			xml 注释 alt + shift + /
			System.out.println( person );  so 
			main psvm
			
			3.配置文件中的值注入
				
				配置文件 
				application.yml
				
					person:
					  lastName: zhansan
					  last-name: zhansan
					  age: 18
					  boss: false
					  brith: 2017/12/12
					  maps: {k1: v1,k2: v2}
					  lists:
						- lisi
						- zhaoliu
					  dog:
						name: 小狗
						age: 12
						
				JavaBean:
				
									/**
				 * 将配置文件中配置的每一个属性的值映射到这个组件中
				 * @ConfigurationProperties : 告诉SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定
				 *      prefix = "person":配置文件中哪个下面的所有属性进行一一映射
				 *  只有这个组件是容器中的组件,才能使用容器提供的@ConfigurationProperties功能;比如快速动态绑定
				 */
				@Component
				@ConfigurationProperties(prefix = "person")
				public class Person {

					private String lastName;
					private Integer age;
					private Boolean boss;
					private Date brith;

					private Map<String,Object> maps;
					private List<Object> lists;
					private  Dog dog;

					public String getLastName() {
						return lastName;
					}

					public void setLastName(String lastName) {
						this.lastName = lastName;
					}

					public Integer getAge() {
						return age;
					}

					public void setAge(Integer age) {
						this.age = age;
					}

					public Boolean getBoss() {
						return boss;
					}

					public void setBoss(Boolean boss) {
						this.boss = boss;
					}

					public Date getBrith() {
						return brith;
					}

					public void setBrith(Date brith) {
						this.brith = brith;
					}

					public Map<String, Object> getMaps() {
						return maps;
					}

					public void setMaps(Map<String, Object> maps) {
						this.maps = maps;
					}

					public List<Object> getLists() {
						return lists;
					}

					public void setLists(List<Object> lists) {
						this.lists = lists;
					}

					public Dog getDog() {
						return dog;
					}

					public void setDog(Dog dog) {
						this.dog = dog;
					}

					@Override
					public String toString() {
						return "Person{" +
								"lastName='" + lastName + '\'' +
								", age=" + age +
								", boss=" + boss +
								", brith=" + brith +
								", maps=" + maps +
								", lists=" + lists +
								", dog=" + dog +
								'}';
					}
				}

			
			我们可以导入配置文件处理器,以后编写配置就又提示了
			
				<!--导入配文件处理器,配置文件进行绑定就会有提示-->
				<dependency>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-configuration-processor</artifactId>
					<optional>true</optional>
				</dependency>

		
	/**
	 * SpringBoot的单元测试
	 *
	 * 可以在测试期间很方便的类似测试编码一样进行自动注入等容器的功能
	 */
	@RunWith(SpringRunner.class)
	@SpringBootTest
	public class Springboot02ConfigApplicationTests {

		@Autowired
		Person person;

		@Test
		public void contextLoads() {

			System.out.println( person );
		}
	}
	
	
	properties 属性赋值是乱码
	
		-> settings -> file encoding -> utf-8
	

@ConfigurationProperties与@Value比较	
		
	/**
     * <bean class="Person">
     *      <property name="lastName" value="字面量/${key}从环境变量,配置文件中获取值/#{spel}"></property>
     * </bean>
     *
     *@Value 同上
     *
     *比较                                    @ConfigurationProperties                                   @Value
     *功能                                   批量注入配置文件中的属性                                   一个一个指定
     *松散绑定(last-name 等价于lastName)     支持                                                      不支持
     *spel                                   不支持                                                    支持
     *jsr303                                 支持(给类上加上@Validated  字段加上@Email)                不支持
     *复杂类型封装例如map list               支持                                                     不支持
     *
     *
     * 配置文件不管是yml 还是properties 都支持
     *
     * 如果说,我们只是在某个业务逻辑中需要获取一下配置文件中的某项值我们就使用@Value
     *
     * 如果说,我们专门编写了一个javabean来和配置文件进行映射,我们就直接使用@ConfigurationProperties
     *
     *
     * 配置文件注入值数据校验
	
@PropertySource  @ImportResource ：

	@PropertySource :加载指定的配置文件 ， @ConfigurationProperties 默认从全局配置文件中获取值
    @ImportResource ：导入spring 的配置文件，让配置文件中的内容生效
		SpringBoot 里面没有Spring的配置文件,我们自己编写的配置文件,也不能自动识别	
		想让Spring的配置文件生效,加载进来  @ImportResource标注在一个配置类上
		
		@ImportResource("classpath:beans.xml")
		导入Spring 的配置文件，让配置文件中的内容生效
		
		
	SpringBoot 推荐给容器中添加组件的方式:
		1.配置类========配置文件
			
			
		配置文件占位符:
			1.随机数
				random.value random.int random.long random.int random.int[1024,65535]
				
				可以通过${random.value} 的方式产生随机数
				
			2.占位符获取之前配置的值,如果没有可以使用:指定默认值
				${person.hello:xsfs}
				
		
				
		
		
	5.Profile:
		
		1.多profile 
			我们在主配置文件编写的时候,文件名可以是application-{profile}.properties/yml
			
			默认使用application.properties的配置; 
			
		
		
		2.yml支持多文档块方式
				
				spring:
				  profiles:
					active: dev

				server:
				 port: 8081

				---
				server:
				  port: 8083
				spring:
				  profiles: dev

				---
				server:
				  port: 8084
				spring:
				  profiles: prod

		
		
		3.激活指定profile
				
				1.在配置文件中指定spring.profiles.active=dev
				2.命令行方式
						命令行:--spring.profiles.active=dev
						配置文件spring.profiles.active=dev
						jvm参数-Dspring.profiles.active=dev
			
		
	
	6.spring boot配置文件加载位置:
		
		spring boot 启动会扫描一下位置的application.properties或者application.yml文件作为Spring Boot 的默认配置文件
		
			-file:./config/  当前项目的 代表当前项目位置
			-file:./
			-classpath:/config/
			-classpath:/
			
			以上是按照优先级高低的顺序,所有文件都会被加载,高优先级配置内容会覆盖低优先级配置内容
			
			
			
			springboot 会从四个位置全部加载主配置文件;互补配置
			
			我们也可以通过spring.config.location来改变默认的配置
				项目打包好以后 我们可以通过命令行参数的形式,启动项目的时候来指定配置文件的的新位置;指定配置文件和默认加载
				的这些配置文件会共同起作用形成互补配置;
					--spring.config.location=D:/application.properties
				
					
	7.外部配置的加载顺序:
	
		SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会
		形成互补配置
		1.命令行参数
		所有的配置都可以在命令行上进行指定
		java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/abc
		多个配置用空格分开； --配置项=值
		
		2.来自java:comp/env的JNDI属性
		
		3.Java系统属性（System.getProperties()）
		
		4.操作系统环境变量
		
		5.RandomValuePropertySource配置的random.*属性值
		
		
		由jar包外向jar包内进行寻找；
		优先加载带profile
		
		6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件
		
		7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件
		再来加载不带profile
		
		8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件
		
		9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件
		
		10.@Configuration注解类上的@PropertySource
		
		11.通过SpringApplication.setDefaultProperties指定的默认属性
		所有支持的配置加载来源；

			
	8、自动配置原理			
		配置文件到底能写什么？怎么写？自动配置原理；
		配置文件能配置的属性参照
			https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties
		
		1、自动配置原理：
		
		1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration
		
		2）、@EnableAutoConfiguration 作用：
			利用EnableAutoConfigurationImportSelector给容器中导入一些组件？
			可以查看selectImports()方法的内容；
			List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置
			
					SpringFactoriesLoader.loadFactoryNames()
					扫描所有jar包类路径下 META‐INF/spring.factories
					把扫描到的这些文件的内容包装成properties对象
					从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器
					中
			
			将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；
		
				org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
				org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
				org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
				org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
				org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
				org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
				org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
				org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\
				org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
				org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
				org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
				org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
				org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
				org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
				org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\
				org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\
				org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
				org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
				org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
				org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
				org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
				org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
				org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
				org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\
				org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\
				org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\
				org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
				org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
				org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
				org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
				org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
				org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
				org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
				org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
				org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
				org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
				org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
				org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
				org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
				org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
				org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
				org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
				org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\
				org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
				org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
				org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
				org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
				org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
				org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
				org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
				org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
				org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\
				org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
				org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
				org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\
				org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\
				org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
				org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\
				org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\
				org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
				org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\
				org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\
				org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
				org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
				org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
				org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\
				org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
				org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\
				org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\
				org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\
				org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\
				org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration

		
		
		每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；
		
		
		3）、每一个自动配置类进行自动配置功能	\


		4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理
		
		精髓：
		1）、SpringBoot启动会加载大量的自动配置类
		2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；
		3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）
		4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这
		些属性的值；
		xxxxAutoConfigurartion：自动配置类；
		给容器中添加组件
		xxxxProperties:封装配置文件中相关属性；
		
		2、细节
			1、@Conditional派生注解（Spring注解版原生的@Conditional作用）
			作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；
		
		
	
		@Conditional扩展注解 作用（判断是否满足当前指定条件）
		@ConditionalOnJava 系统的java版本是否符合要求
		@ConditionalOnBean 容器中存在指定Bean；
		@ConditionalOnMissingBean 容器中不存在指定Bean；
		@ConditionalOnExpression 满足SpEL表达式指定
		@ConditionalOnClass 系统中有指定的类
		@ConditionalOnMissingClass 系统中没有指定的类
		@ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean
		@ConditionalOnProperty 系统中指定的属性是否有指定的值
		@ConditionalOnResource 类路径下是否存在指定资源文件
		@ConditionalOnWebApplication 当前是web环境
		@ConditionalOnNotWebApplication 当前不是web环境
		@ConditionalOnJndi JNDI存在指定项
		
		自动配置类必须在一定的条件下才能生效；
		我们怎么知道哪些自动配置类生效；
		我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置
		类生效；
		=========================
		AUTO‐CONFIGURATION REPORT
		=========================
		Positive matches:（自动配置类启用的）
		‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
		DispatcherServletAutoConfiguration matched:
		
		
		
三、Spring Boot 与 日志

	1、日志框架
	小张；开发一个大型系统；
	
	1、System.out.println("")；将关键数据打印在控制台；去掉？写在一个文件？
	
	2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar；
	
	3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？
	
	4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；
	
	5、JDBC---数据库驱动；
	写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；
	给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；
	
	
	市面上的日志框架；
	JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j....
	
	
	日志门面 （日志的抽象层） 											日志实现
	JCL（Jakarta Commons Logging） 	SLF4j（Simple Logging)				Log4j JUL（java.util.logging）
	Facade for Java） 				
	jboss-logging														Log4j2 Logback
	
	左边选一个门面（抽象层）、右边来选一个实现；
	日志门面： SLF4J；
	日志实现：Logback；
	
	SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘
	SpringBoot选用 SLF4j和logback；
	
	2、SLF4j使用
	
	
		1、如何在系统中使用SLF4j https://www.slf4j.org
			以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；
			给系统里面导入slf4j的jar和 logback的实现jar
			
			
			图示；
			import org.slf4j.Logger;
			import org.slf4j.LoggerFactory;
			public class HelloWorld {
			public static void main(String[] args) {
			Logger logger = LoggerFactory.getLogger(HelloWorld.class);
			logger.info("Hello World");
			}
			}

			
	2、遗留问题
		a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx
		统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？
		
		
		如何让系统中所有的日志都统一到slf4j；
		1、将系统中其他日志框架先排除出去；
		2、用中间包来替换原有的日志框架；
		3、我们导入slf4j其他的实现
		
		
		
		总结：
		1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录
		2）、SpringBoot也把其他的日志都替换成了slf4j；
		3）、中间替换包？
	


	4、日志使用；
		1、默认配置
		SpringBoot默认帮我们配置好了日志	

		//记录器
		Logger logger = LoggerFactory.getLogger(getClass());
		@Test
		public void contextLoads() {
		//System.out.println();
		//日志的级别；
		//由低到高 trace<debug<info<warn<error
		//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效
		logger.trace("这是trace日志...");
		logger.debug("这是debug日志...");
		//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root
		级别
		logger.info("这是info日志...");
		logger.warn("这是warn日志...");
		logger.error("这是error日志...");
		}
		
		日志输出格式：
		%d表示日期时间，
		%thread表示线程名，
		%‐5level：级别从左显示5个字符宽度
		%logger{50} 表示logger名字最长50个字符，否则按照句点分割。
		%msg：日志消息，
		%n是换行符
		‐‐>
		%d{yyyy‐MM‐dd HH:mm:ss.SSS} [%thread] %‐5level %logger{50} ‐ %msg%n
		
	SpringBoot修改日志的默认配置
		2、指定配置
		给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了
		logback.xml：直接就被日志框架识别了；
		logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot
		的高级Profile功能
		logging.level.com.atguigu=trace
		
		#logging.path=
		
		# 不指定路径在当前项目下生成springboot.log日志
		# 可以指定完整的路径；
		#logging.file=G:/springboot.log
		
		# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件
		logging.path=/spring/log
		
		# 在控制台输出的日志的格式
		logging.pattern.console=%d{yyyy‐MM‐dd} [%thread] %‐5level %logger{50} ‐ %msg%n
		
		# 指定文件中日志输出的格式
		logging.pattern.file=%d{yyyy‐MM‐dd} === [%thread] === %‐5level === %logger{50} ==== %msg%n
		
		
		2、指定配置
			给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的
			
		
			Logging System Customization
			Logback logback-spring.xml , logback-spring.groovy , logback.xml orlogback.groovy
			Log4j2 log4j2-spring.xml or log4j2.xml
			JDK (Java Util
			Logging)    logging.properties
		
		logback.xml：直接就被日志框架识别了；
		logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot
		的高级Profile功能
			
		<springProfile name="staging">
		<!‐‐ configuration to be enabled when the "staging" profile is active ‐‐>
		可以指定某段配置只在某个环境下生效
		</springProfile>
						
						
						
	
	spring boot web 开发:
	
		1、简介
			使用SpringBoot；
			1）、创建SpringBoot应用，选中我们需要的模块；
			2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来
			3）、自己编写业务代码；
			
			
		自动配置原理？
			这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx
			
			xxxxAutoConfiguration：帮我们给容器中自动配置组件；
			xxxxProperties:配置类来封装配置文件的内容；

**********************************************************************************
thymeleaf 解析标签


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.3.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.atguigu</groupId>
	<artifactId>spring-boot-04-web-restfulcrud</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>spring-boot-04-web-restfulcrud</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>

		<!--引入web模块-->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>2.0.0</version>
		</dependency>

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<!--引入jquery的webjar -->
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>jquery</artifactId>
			<version>3.3.1-2</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>


	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>

			
			
package com.atguigu.springboot.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.Arrays;
import java.util.Map;

/**
 * Created by Administrator on 2019-03-27.
 */
@Controller
public class HelloController {

    @ResponseBody
    @RequestMapping("/hello")
    public String hello() {

        return "hello";
    }


    //查出一些数据在页面展示
    @RequestMapping("/success")
    public String success(Map<String,Object> map) {

        map.put("hello","<h1>你好<h1>");
        map.put("users", Arrays.asList("zhansan","lisi","wangwu"));


        return "success";
    }
}


			
						
						
		<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1>成功!</h1>
    <div th:text="${#text}" >
    </div>
    <hr>
    <div th:text="${hello}"></div>
    <div th:utext="${hello}"></div>
    <hr>

    <!--th:each 每次遍历都会生成当前这个标签  :三个h4-->
    <h4 th:text="${user}" th:each="user:${users}"></h4>

    <hr>

    <h4>
           <span th:each="user:${users}" >[[${user}]]</span>
    </h4>

</body>
</html>				
					
					
				
				

 

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;

@SpringBootApplication
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
public class SpringBoot04WebRestfulcrudApplication {

	public static void main(String[] args) {

		SpringApplication.run(SpringBoot04WebRestfulcrudApplication.class, args);
	}
}
**********************************************************************************				
				
4、SpringMVC自动配置

https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications

springboot 自动配置好了springmvc

以下是springboot对springmvc的默认配置:

Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
	自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何
	渲染（转发？重定向？））
	
	ContentNegotiatingViewResolver：组合所有的视图解析器的；
	如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来
	
	
Support for serving static resources, including support for WebJars (see below).
	静态资源文件夹路径,webjars
	
	
Automatic registration of Converter, GenericConverter, Formatter beans.
	Converter：转换器； public String hello(User user)：类型转换使用Converter
	Formatter 格式化器； 2017.12.17===Date
	
	@Bean
	@ConditionalOnProperty(prefix = "spring.mvc", name = "date‐format")//在文件中配置日期格
	式化的规则
	public Formatter<Date> dateFormatter() {
	return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件
	}

Support for HttpMessageConverters (see below).
	springMVC用来转换Http请求和响应的；User---Json；
	HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter；
	自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中
	（@Bean,@Component）
	

Automatic registration of MessageCodesResolver (see below). ).定义错误代码生成规则
Static index.html support.
Custom Favicon support (see below).

Automatic use of a ConfigurableWebBindingInitializer bean (see below).				
我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）				
初始化WebDataBinder；
请求数据=====JavaBean；
				
org.springframework.boot.autoconfigure.web：web的所有自动场景；	




5、如何修改SpringBoot的默认配置
模式：
1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如
果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默
认的组合起来；
2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置
3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置		
			
If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration
(interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type
WebMvcConfigurerAdapter , but without @EnableWebMvc . If you wish to provide custom instances of
RequestMappingHandlerMapping , RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver
you can declare a WebMvcRegistrationsAdapter instance providing such components.
If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with
@EnableWebMvc 			


2、扩展SpringMVC


<mvc:view‐controller path="/hello" view‐name="success"/>
<mvc:interceptors>
<mvc:interceptor>
<mvc:mapping path="/hello"/>
<bean></bean>
</mvc:interceptor>
</mvc:interceptors>

编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc;
既保留了所有的自动配置，也能用我们扩展的配置；


//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能
@Configuration
	public class MyMvcConfig extends WebMvcConfigurerAdapter {
	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
	// super.addViewControllers(registry);
	//浏览器发送 /atguigu 请求来到 success
	registry.addViewController("/atguigu").setViewName("success");
	}
}		


ctrl + o 提示重写的方法
			
/**
 * Created by Administrator on 2019-04-09.
 *
 * 使用WebMvcConfigurer可以扩展springmvc的功能
 */
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {


    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {

        configurer.enable();

    }


    @Override
    public void addViewControllers(ViewControllerRegistry registry) {

        //浏览器发送 /atguigu 请求来到success页面
        registry.addViewController("atguigu").setViewName("success");
    }
}


原理：
1）、WebMvcAutoConfiguration是SpringMVC的自动配置类
2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class)


@Configuration
public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {

private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
//从容器中获取所有的WebMvcConfigurer


@Autowired(required = false)
public void setConfigurers(List<WebMvcConfigurer> configurers) {
if (!CollectionUtils.isEmpty(configurers)) {
this.configurers.addWebMvcConfigurers(configurers);
//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；

@Override
// public void addViewControllers(ViewControllerRegistry registry) {
// for (WebMvcConfigurer delegate : this.delegates) {
// delegate.addViewControllers(registry);
// }
}
}
}

3）、容器中所有的WebMvcConfigurer都会一起起作用；
4）、我们的配置类也会被调用；
效果：SpringMVC的自动配置和我们的扩展配置都会起作用；
			
*********************************************************************************		

全面接管SpringMvc

SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了
我们需要在配置类中添加@EnableWebMvc即可；	


//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能
@EnableWebMvc
@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter {
@Override
public void addViewControllers(ViewControllerRegistry registry) {
// super.addViewControllers(registry);
//浏览器发送 /atguigu 请求来到 success
registry.addViewController("/atguigu").setViewName("success");
}
}		

原理：
为什么@EnableWebMvc自动配置就失效了；

1）@EnableWebMvc的核心					
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {

2）、@Configuration
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {	


3）、
@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
WebMvcConfigurerAdapter.class })
//容器中没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration 	 {


4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来

5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；

5、如何修改SpringBoot的默认配置

模式：
1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如
果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默
认的组合起来；
2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置
3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置

*********************************************************************************				
						
crud:

	默认访问首页：
		
	 */
	 
1.第一种方式
@Controller
public class HelloController {

    @RequestMapping({"/" ,"/index.html"})
    public String index() {

        return "index";
    }

}	

2.第二种方式 推荐的方式

/**
 * Created by Administrator on 2019-04-09.
 *
 * 使用WebMvcConfigurer可以扩展springmvc的功能
 */
//@EnableWebMvc
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {


//    @Override
//    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
//
//        configurer.enable();
//
//    }

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {

        //浏览器发送 /atguigu 请求来到success页面
        registry.addViewController("atguigu").setViewName("success");
    }

    //所有的WebMvcConfigurer组件都会一起起作用
    @Bean
    public WebMvcConfigurer webMvcConfigurer() {

       return new WebMvcConfigurer() {

            @Override
            public void addViewControllers(ViewControllerRegistry registry) {

                registry.addViewController("/").setViewName("login");
                registry.addViewController("/login.html").setViewName("login");
            }
        };
    }
}

<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<meta name="description" content="">
		<meta name="author" content="">
		<title>Signin Template for Bootstrap</title>
		<!-- Bootstrap core CSS   href="asserts/css/bootstrap.min.css"-->
		这个路径可以通过查看jar包的方式查看
		<link  th:href="@{/webjars/bootstrap/4.3.1/css/bootstrap.min.css}" rel="stylesheet">
		<!-- Custom styles for this template href="asserts/css/signin.css" -->
		<link  th:href="@{/asserts/css/signin.css}"  rel="stylesheet">
	</head>

	<body class="text-center">
		<form class="form-signin" action="dashboard.html">
			<img class="mb-4" th:src="@{/asserts/img/bootstrap-solid.svg}" alt="" width="72" height="72">
			<h1 class="h3 mb-3 font-weight-normal">Please sign in</h1>
			<label class="sr-only">Username</label>
			<input type="text" class="form-control" placeholder="Username" required="" autofocus="">
			<label class="sr-only">Password</label>
			<input type="password" class="form-control" placeholder="Password" required="">
			<div class="checkbox mb-3">
				<label>
          <input type="checkbox" value="remember-me"> Remember me
        </label>
			</div>
			<button class="btn btn-lg btn-primary btn-block" type="submit">Sign in</button>
			<p class="mt-5 mb-3 text-muted">© 2017-2018</p>
			<a class="btn btn-sm">中文</a>
			<a class="btn btn-sm">English</a>
		</form>

	</body>

</html>


debug=true
#spring.resources.static-locations=classpath:/hello/,classpath:/atguigu/
server.servlet.context-path=/crud

*************************************

登录页面的国际化：

以前的springmvc的方式

2）、国际化
1）、编写国际化配置文件；
2）、使用ResourceBundleMessageSource管理国际化资源文件
3）、在页面使用fmt:message取出国际化内容


步骤：
1）、编写国际化配置文件，抽取页面需要显示的国际化消息
	1.创建国际化资源文件
	在resource文件夹下创建 i18n文件夹 idea会自动提示
	在i18n文件夹下创建 login.properties login_zh_CN.properties login_en_US.properties 
	
	login.btn=登录~					
	login.password=密码~
	login.remember=记住我~
	login.tip=请登录~
	login.username=用户名~
	
	login.btn=Sign In
	login.password=password
	login.remember=Remember me
	login.tip=Please sign in
	login.username=UserName
	
	login.btn=登录
	login.password=密码
	login.remember=记住我
	login.tip=请登录
	login.username=用户名
	
	
	@ConfigurationProperties(prefix = "spring.messages")
		public class MessageSourceAutoConfiguration {
		/**
		* Comma‐separated list of basenames (essentially a fully‐qualified classpath
		* location), each following the ResourceBundle convention with relaxed support for
		* slash based locations. If it doesn't contain a package qualifier (such as
		* "org.mypackage"), it will be resolved from the classpath root.
		*/
		private String basename = "messages";
		//我们的配置文件可以直接放在类路径下叫messages.properties；
		@Bean
		public MessageSource messageSource() {
		ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
		if (StringUtils.hasText(this.basename)) {
		//设置国际化资源文件的基础名（去掉语言国家代码的）
		messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(
		StringUtils.trimAllWhitespace(this.basename)));
		} 
		if (this.encoding != null) {
		messageSource.setDefaultEncoding(this.encoding.name());
		} 
		messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);
		messageSource.setCacheSeconds(this.cacheSeconds);
		messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);
		return messageSource;
		}
	
	


3）、去页面获取国际化的值；

	修改properies 的编码方式  file -> other settion -> file encoding
	
	
	<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<meta name="description" content="">
		<meta name="author" content="">
		<title>Signin Template for Bootstrap</title>
		<!-- Bootstrap core CSS   href="asserts/css/bootstrap.min.css"-->
		<link  th:href="@{/webjars/bootstrap/4.3.1/css/bootstrap.min.css}" rel="stylesheet">
		<!-- Custom styles for this template href="asserts/css/signin.css" -->
		<link  th:href="@{/asserts/css/signin.css}"  rel="stylesheet">
	</head>

	<body class="text-center">
		<form class="form-signin" action="dashboard.html">
			<img class="mb-4" th:src="@{/asserts/img/bootstrap-solid.svg}" alt="" width="72" height="72">
			<h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}"></h1>
			<label class="sr-only">Username</label>
			<input type="text" class="form-control" th:placeholder="#{login.username}" required="" autofocus="">
			<label class="sr-only">Password</label>
			<input type="password" class="form-control" th:placeholder="#{login.password}" required="">
			<div class="checkbox mb-3">
				<label>
          <input type="checkbox" value="remember-me"> [[#{login.remember}]]
        </label>
			</div>
			<button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#{login.btn}" ></button>
			<p class="mt-5 mb-3 text-muted">© 2017-2018</p>
			<a class="btn btn-sm">中文</a>
			<a class="btn btn-sm">English</a>
		</form>

	</body>

</html>
	
	
效果：根据浏览器语言设置的信息切换了国际化

原理：
国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）


@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")
public LocaleResolver localeResolver() {
if (this.mvcProperties
.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
return new FixedLocaleResolver(this.mvcProperties.getLocale());
} A
cceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
return localeResolver;
}
默认的就是根据请求头带来的区域信息获取Locale进行国际化


4）、点击链接切换国际化

/**
* 可以在连接上携带区域信息
*/
/**
 *
 *  可以在连接上携带区域信息
 */
public class MyLocaleResolver implements LocaleResolver{


    @Override
    public Locale resolveLocale(HttpServletRequest request) {

       String l = request.getParameter("l");
        Locale locale = Locale.getDefault();

        if ( !StringUtils.isEmpty( l ) ) {

            String[] split = l.split("_");
            locale = new Locale(split[0],split[1]);
        }

        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale) {

    }
}


将这个类添加到容器中就可以了


去除缓存

	开发期间模板引擎页面修改以后，要实时生效
		1）、禁用模板引擎的缓存
		# 禁用缓存
		spring.thymeleaf.cache=false
		
		2）、页面修改完成以后ctrl+f9：重新编译；
		
		<p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"></p>
**************************************************************************	
		
				
	
			
