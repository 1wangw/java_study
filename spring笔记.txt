
Spring 是什么(1)

	Spring 是一个开源框架.
	Spring 为简化企业级应用开发而生. 使用 Spring 可以使简单的 JavaBean 实现以前只有 EJB 才能实现的功能.
	Spring 是一个 IOC(DI) 和 AOP 容器框架.
	
	
	具体描述 Spring:
	
		轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API(不需要继承spring提供的接口)
		
		依赖注入(DI --- dependency injection、IOC)
		
		面向切面编程(AOP --- aspect oriented programming)
		
		容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期
		
		框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象
		
		一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 
		
		（实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC）
	
	
	安装 SPRING TOOL SUITE
	
		SPRING TOOL SUITE 是一个 Eclipse 插件，利用该插件可以更方便的在 Eclipse 平台上开发基于 Spring 的应用。
		安装方法说明（springsource-tool-suite-3.4.0.RELEASE-e4.3.1-updatesite.zip）
		Help --> Install New Software...
		Click Add... 
		In dialog Add Site dialog, click Archive... 
		Navigate to springsource-tool-suite-3.4.0.RELEASE-e4.3.1-updatesite.zip  and click  Open 
		Clicking OK in the Add Site dialog will bring you back to the dialog 'Install' 
		Select the xxx/Spring IDE that has appeared 
		Click Next  and then Finish 
		Approve the license 
		Restart eclipse when that is asked
		
		
		spring 核心java包:
		
			beans core context expression commons-logging 
			
			Spring 的配置文件: 一个典型的 Spring 项目需要创建一个或多个 Bean 配置文件,
			 这些配置文件用于在 Spring IOC 容器里配置 Bean. 
			Bean 的配置文件可以放在 classpath 下, 也可以放在其它目录下
		
		
		IOC(Inversion of Control)：其思想是反转资源获取的方向. 
		传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后,
		 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式
		 
		DI(Dependency Injection) — IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如: setter 方法)
		接受来自如容器的资源注入. 
		相对于 IOC 而言，这种表述更直接
		
		
		IOC 前生 --- 分离接口与实现
		
		IOC 前生 --- 采用工厂设计模式
		
		IOC --- 采用反转控制
		
		ApplicationContext 的主要实现类：
			ClassPathXmlApplicationContext：从 类路径下加载配置文件
			FileSystemXmlApplicationContext: 从文件系统中加载配置文件
			
		ApplicationContext 在初始化上下文时就实例化所有单例的 Bean。
		
		在 Spring 的 IOC 容器里配置 Bean
			在 xml 文件中通过 bean 节点来配置 bean
			id：Bean 的名称。
				在 IOC 容器中必须是唯一的
				若 id 没有指定，Spring 自动将权限定性类名作为 Bean 的名字
				id 可以指定多个名字，名字之间可用逗号、分号、或空格分隔
				
	<bean id="helloWorld" class="com.atguigu.srping.beans.HelloWorld" >
		<!-- 
			属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象,实际应用中最常用的注入方式
		 -->
		<property name="name" value="Spring" ></property>
	</bean>
				
		依赖注入的三种方式:
		
			属性注入
		<bean id="helloWorld" class="com.atguigu.srping.beans.HelloWorld" >
		<!-- 
			属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象,实际应用中最常用的注入方式
		 -->
		<property name="name" value="Spring" ></property>
			</bean>
			
		构造器注入
					
				<!-- 通过构造方法配置bean的属 性 -->
				<bean id="car" class="com.atguigu.srping.beans.Car" >
					<!-- 按照参数顺序配置 -->
					<!-- 也可以按照index=0 -->
					<!-- 可以通过type 区别重载的构造器  index 可以和type混合使用  value可以通过value子节点注入
						 若字面值包含特殊字符可以通过<![CDATA[]]>
					 -->
					<constructor-arg value="Audi"></constructor-arg>
					<constructor-arg value="Shanghai"></constructor-arg>
					<constructor-arg value="300000"></constructor-arg>
				</bean>
				
					<!-- 若一个 bean 有多个构造器, 如何通过构造器来为 bean 的属性赋值 -->
				<!-- 可以根据 index 和 value 进行更加精确的定位. (了解) -->
				<bean id="car1" class="com.atguigu.srping.beans.Car">
					<constructor-arg value="KUGA" index="1"></constructor-arg>
					<constructor-arg value="ChangAnFord" index="0"></constructor-arg>
					<constructor-arg value="250000" type="float"></constructor-arg>
				</bean>
				
				<bean id="car2" class="com.atguigu.srping.beans.Car">
					<constructor-arg value="ChangAnMazda"></constructor-arg>
					<!-- 若字面值中包含特殊字符, 则可以使用 DCDATA 来进行赋值. (了解) -->
					<constructor-arg>
						<value><![CDATA[<ATARZA>]]></value>
					</constructor-arg>
					<constructor-arg value="180" type="int"></constructor-arg>
				</bean>
			
			工厂方法注入
			
			
		引用其它 Bean
				
				组成应用程序的 Bean 经常需要相互协作以完成应用程序的功能.
				 要使 Bean 能够相互访问, 就必须在 Bean 配置文件中指定对 Bean 的引用
				在 Bean 的配置文件中, 可以通过 <ref> 元素或 ref  属性为 Bean 的属性或构造器参数指定对 Bean 的引用. 
				也可以在属性或构造器里包含 Bean 的声明, 这样的 Bean 称为内部 Bean
				
					
			<bean id="person" class="com.atguigu.srping.beans.Person"> 
				<property name="name" value="Tom"></property>
				<property name="age" value="24"></property>
				<property name="car" ref="car2"></property>
			</bean>
			
						
					
		<!-- 使用内部bean 不能被外部引用 只能在内部使用-->
		当 Bean 实例仅仅给一个特定的属性使用时, 可以将其声明为内部 Bean. 
		内部 Bean 声明直接包含在 <property> 或 <constructor-arg> 元素里, 不需要设置任何 id 或 name 属性
		内部 Bean 不能使用在任何其他地方
		
		<bean id="person1" class="com.atguigu.srping.beans.Person"> 
			<property name="name" value="Tom"></property>
			<property name="age" value="24"></property>	
			<property name="car">
				<bean class="com.atguigu.srping.beans.Car"  >	
				</bean>
			</property>
		</bean>
		
	<!-- 测试赋值null -->
		<bean id="person2" class="com.atguigu.srping.beans.Person"> 
		<property name="name">
			<null></null>
		</property>
		<property name="age" value="24"></property>	
		<property name="car">
			<bean class="com.atguigu.srping.beans.Car"  >	
			</bean>
		</property>
	</bean>
	
	<!--测试级联属性赋值  注意:属性需要先初始后才可以给级联属性赋值 否则有一场和struct2不同 不经常用-->
	
	<bean id="person2" class="com.atguigu.srping.beans.Person"> 
		<property name="name">
			<null></null>
		</property>
		<property name="age" value="24"></property>	
		<property name="car" ref="car">
		</property>
		<property name="car.price" value="8880000"></property>
	</bean>
	
	集合属性
		 
	在 Spring中可以通过一组内置的 xml 标签(例如: <list>, <set> 或 <map>) 来配置集合属性.
		配置 java.util.List 类型的属性, 需要指定 <list>  标签, 
		在标签里包含一些元素. 这些标签可以通过 <value> 指定简单的常量值, 
		通过 <ref> 指定对其他 Bean 的引用. 通过<bean> 指定内置 Bean 定义. 
		通过 <null/> 指定空元素. 甚至可以内嵌其他集合.
		数组的定义和 List 一样, 都使用 <list>
		配置 java.util.Set 需要使用 <set> 标签, 定义元素的方法与 List 一样.
		 
	<bean id="person3" class="com.atguigu.srping.beans.collecion.Person">
		<property name="name" value="Mike"></property>
		<property name="age" value="27"></property>
		<property name="cars">
			<list>
				<ref bean="car2"/>
				<ref bean="car1"/>
			</list>
		</property>
		
	</bean>
	
	集合属性
		Java.util.Map 通过 <map> 标签定义, <map> 标签里可以使用多个 <entry> 作为子标签. 每个条目包含一个键和一个值. 
		必须在 <key> 标签里定义键
		因为键和值的类型没有限制, 所以可以自由地为它们指定 <value>, <ref>, <bean> 或 <null> 元素. 
		可以将 Map 的键和值作为 <entry> 的属性定义: 简单常量使用 key 和 value 来定义; Bean 引用通过 key-ref 和 value-ref 属性定义
		使用 <props> 定义 java.util.Properties, 该标签使用多个 <prop> 作为子标签. 每个 <prop> 标签必须定义 key 属性.
		
		 
 	<bean id="person3" class="com.atguigu.srping.beans.collecion.Person">
		<property name="name" value="Mike"></property>
		<property name="age" value="27"></property>
		<property name="cars">
			<map>
				<entry key="AA" value-ref="car"></entry>
				<entry key="BB" value-ref="car1"></entry>
			</map>
		</property>
		
	</bean>
	
	使用Properties
	
	<bean id="dataSource" class="com.atguigu.srping.beans.DataSource">
		<property name="properties">
			<props>
				<prop key="name">root</prop>
				<prop key="password">1234</prop>
			</props>
		</property>
	</bean>
	
	如何将集合拿出来	
		
	<!-- 配置独立的集合bean 以供多个bean 进行引用 -->
	
	需要导入如下命名空间
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util
	/spring-util-4.3.xsd"
	
	<util:list id="cars" >
		<bean></bean>
		<bean></bean>
		<bean></bean>
	</util:list>
	
	使用 p 命名空间
		为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。
		Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过 <bean> 元素属性的方式配置 Bean 的属性。
		使用 p 命名空间后，基于 XML 的配置方式将进一步简化
	
		<!-- 通过p命名空间给属性赋值  需要先导入p命名空间  相对于传统的配置方式更加的简洁-->

			<bean id="person5" class="com.atguigu.srping.beans.collecion.Person" p:age="30"
				p:name="atguigu" 
				>
		
			</bean>
		</beans>
		 
		 
	bean的自动装配:
		
		Spring IOC 容器可以自动装配 Bean. 需要做的仅仅是在 <bean> 的 autowire 属性里指定自动装配的模式 
		
		byType(根据类型自动装配): 若 IOC 容器中有多个与目标 Bean 类型一致的 Bean. 在这种情况下, Spring 将无法判定哪个 Bean 最合适该属性, 所以不能执行自动装配.
		
		byName(根据名称自动装配): 必须将目标 Bean 的名称和属性名设置的完全相同.
		
		constructor(通过构造器自动装配): 当 Bean 中存在多个构造器时, 此种自动装配方式将会很复杂. 不推荐使用
		
		
			<bean id="address" class="com.atguigu.srping.beans.autowire.Address"
		p:city="Beijing" p:street="HuiLongGuan"
		>
		</bean>
	
		<bean id="car" class="com.atguigu.srping.beans.autowire.Car"
		p:brand="Audi" p:price="300000"
		>
		</bean>
		
		<!-- 可以用  autowire="byName" 指定自动装配的方式
			byName 根据bean的名字和bean的setter风格的属性名进行自动装配
			若有匹配的则装配,若没有匹配的则不进行装配
			
			autowire="byType"  根据bean的类型和当前bead的属性的类型进行自动装配
			若ioc容器中有一个以上匹配的类型bean则抛出异常
		-->
		<bean id="person" autowire="byType"  class="com.atguigu.srping.beans.autowire.Person"
		>
		</bean>
		
		在 Bean 配置文件里设置 autowire 属性进行自动装配将会装配 Bean 的所有属性. 然而, 若只希望装配个别属性时, 
		autowire 属性就不够灵活了
		
		autowire 属性要么根据类型自动装配, 要么根据名称自动装配, 不能两者兼而有之.
		
		一般情况下，在实际的项目中很少使用自动装配功能，因为和自动装配功能所带来的好处比起来，明确清晰的配置文档更有说服力一些
		
	继承 Bean 配置(是配置上的继承)
		
		<!-- bean 配置的继承 :使用bean的parent属性指定继承那个bean的配置 
			
			Spring 允许继承 bean 的配置, 被继承的 bean 称为父 bean. 继承这个父 Bean 的 Bean 称为子 Bean
			子 Bean 从父 Bean 中继承配置, 包括 Bean 的属性配置
			子 Bean 也可以覆盖从父 Bean 继承过来的配置
				
			父 Bean 可以作为配置模板, 也可以作为 Bean 实例. 若只想把父 Bean 作为模板, 
			可以设置 <bean> 的abstract 属性为 true, 这样 Spring 将不会实例化这个 Bean
			
			并不是 <bean> 元素里的所有属性都会被继承. 比如: autowire, abstract 等.
			
			
			也可以忽略父 Bean 的 class 属性, 让子 Bean 指定自己的类, 而共享相同的属性配置.
			 但此时 abstract 必须设为 true
			 
			若一个bean的class属性没有被指定则该beanbi需是一个抽象bean	
		-->
		<bean   id="address2" class="com.atguigu.srping.beans.relation.Address"
		 	p:street="DaZhongSi" parent="address"
		>
		</bean>
	
	依赖 Bean 配置
		
		前置依赖 
		
		Spring 允许用户通过 depends-on 属性设定 Bean 前置依赖的Bean，
		前置依赖的 Bean 会在本 Bean 实例化之前创建好
		如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称
		
		
		<!-- 要求配置Person时 必须有一个关联的car 换句话说person这个bean 依赖于car -->
		<bean id="person" class="com.atguigu.srping.beans.relation.Person" 
			depends-on="car" p:name="Tom" p:address-ref="address2"
		> </bean>
	
		
	配置bean的作用域：
		默认是单例的
	
		 singleton:默认值,容器初始化时创建,在整个容器的生命周期内只创建这一个bean;
		 prototype:每次都会创建一个新的实例
		 request:每次http请求都会创建一个新的,该作用域只适用于WebApplicationContext环境
		 session:同一个httpsession共享一个bean,不同的http session 使用不同的bean,
		 			该作用域只适用于WebApplicationContext环境域
		 			
		
	使用外部属性文件
		
		1.在配置文件里配置 Bean 时, 
		有时需要在 Bean 的配置里混入系统部署的细节信息(例如: 文件路径, 数据源配置信息等). 而这些部署细节实际上需要和 Bean 配置相分离
			
			
		2.Spring 提供了一个 PropertyPlaceholderConfigurer 的 BeanFactory 后置处理器, 
		这个处理器允许用户将 Bean 配置的部分内容外移到属性文件中. 可以在 Bean 配置文件里使用形式为 ${var} 的变量, 
		PropertyPlaceholderConfigurer 从属性文件里加载属性, 并使用这些属性来替换变量
		
		3.Spring 还允许在属性文件中使用 ${propName}，以实现属性之间的相互引用。
		
		
		4.Spring 2.5 之后: 可通过 <context:property-placeholder> 元素简化:
			<beans> 中添加 context Schema 定义
		在配置文件中加入如下配置: 
			<context:property-placeholder location="classpath:db.properties"/>
				
				
		5.之前
		<bean  class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="classpath:db.properties"></property>
		</bean>	
		
		6引用外部资源文件
		
		<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
				<property name="user" value="${user}"></property>
				<property name="password" value="${password}"></property>
				<property name="jdbcUrl" value="${jdbcUrl}"></property>
				<property name="driverClass" value="${dirverClass}"></property>
		</bean>		
		
		
	Spring表达式语言：SpEL
	 
		Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。
		
		语法类似于 EL：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL
		
		SpEL 为 bean 的属性进行动态赋值提供了便利
		
		通过 SpEL 可以实现：
				通过 bean 的 id 对 bean 进行引用
				调用方法以及引用对象中的属性
				计算表达式的值
				正则表达式的匹配
		
		SpEL：字面量
			字面量的表示：
			整数：<property name="count" value="#{5}"/>
				小数：<property name="frequency" value="#{89.7}"/>
				科学计数法：<property name="capacity" value="#{1e4}"/>
				String可以使用单引号或者双引号作为字符串的定界符号：<property name=“name” value="#{'Chuck'}"/> 或 <property name='name' value='#{"Chuck"}'/>
				Boolean：<property name="enabled" value="#{false}"/>
			
		SpEL：引用 Bean、属性和方法（1）
			
		<!-- 使用spel 为属性赋值 -->
		<bean id="address"  class="com.atguigu.srping.beans.spel.Address"> 
			<property name="city" value="#{'BeiJing'}"></property>
			<property name="street" value="WuDaoKou"></property>
		</bean>
		
		<bean id="car" class="com.atguigu.srping.beans.spel.Car">
			<property name="brand" value="Audi"></property>
			<property name="price" value="500000"></property>
			<!-- 使用spel引用类的静态属性 -->
			<property name="tyrePerimeter" value="#{T(java.lang.Math).PI * 80 }"></property>
	   </bean>
		
		<bean id="person" class="com.atguigu.srping.beans.spel.Person">
			<property name="name" value="Tom"></property>
				<!-- 使用spel引用其他bean的属性 -->
			<property name="city" value="#{address.city}"></property>
			<!-- 使用spel来引用其他的bean -->
			<property name="car" value="#{car}"></property>
			<!-- 使用spel来表达式-->
			<property name="info" value="#{car.price > 300000 ?'金领':'白领'}"></property>
	   </bean>
	
		
	
	bean 的生命周期：
		
		1.IOC 容器中 Bean 的生命周期方法		
		
			Spring IOC 容器可以管理 Bean 的生命周期, Spring 允许在 Bean 生命周期的特定点执行定制的任务	
			
			Spring IOC 容器对 Bean 的生命周期进行管理的过程:
				通过构造器或工厂方法创建 Bean 实例
				为 Bean 的属性设置值和对其他 Bean 的引用
				调用 Bean 的初始化方法
				Bean 可以使用了
				当容器关闭时, 调用 Bean 的销毁方法
				
			在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法.
			
			
		<bean id="car" class="com.atguigu.srping.beans.cycle.Car" init-method="init" destroy-method="destroy"> 
			<property name="brand" value="Audi"></property>
			<property name="price" value="300000"></property>
			<property name="tyrePerimeter" value="#{T(java.lang.Math).PI * 80 }"></property>
		</bean>
		
	2.创建 Bean 后置处理器
	
		Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理.
		
		对Bean 后置处理器而言, 需要实现  接口BeanPostProcessor 在初始化方法被调用前后, 
		Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法
		
		Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理,
		
		public class MyBeanPostProcessor implements BeanPostProcessor 
		<bean  class="com.atguigu.srping.beans.cycle.MyBeanPostProcessor"> </bean>
		
		添加 Bean 后置处理器后 Bean 的生命周期
		
			Spring IOC 容器对 Bean 的生命周期进行管理的过程:
				通过构造器或工厂方法创建 Bean 实例
				为 Bean 的属性设置值和对其他 Bean 的引用
				将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法
				调用 Bean 的初始化方法 
				将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法
				Bean 可以使用了
				当容器关闭时, 调用 Bean 的销毁方法
			
				public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
						System.out.println( "postProcessAfterInitialization" );
						return bean ;
				}
				
				bean:bean本身实例
				beanName:IOC容器配置的bean的名字
				返回值:是实际上返回给用户的那个bean 注意可以在两个方法中修改bean 甚至返回一个新的bean;
			
		通过调用静态工厂方法创建 Bean
		
					<!-- 通过静态工厂方法来配置bean,注意不是配置静态工厂方法实例，而是配置bean实例 -->
			
			<!-- 
				class属性:指向静态工厂方法的全类名
				factory-method:执行静态工厂方法名
				constructor-arg:如果工厂方法需要传入参数则使用其来配置参数
			 -->
			
			<bean id="car1"  class="com.atguigu.srping.beans.factory.StaticCarFactory" 
			factory-method="getCar"
			>
				 <constructor-arg value="audi"></constructor-arg>
			</bean>
			
						 * 
			 * 静态方法:直接调用某个类的静态方法就可以返回bean的实例
			 * @author Administrator
			 *
			public class StaticCarFactory {
			
				private static Map<String , Car > cars = new HashMap<String , Car>();
				
				static {
					
					cars.put("audi", new Car( "audi" , 300000 , 28) );
					cars.put("fute", new Car( "fute" , 400000 , 28) );
				}
				
				
				/**
				 * 静态工厂方法
				 * @param name
				 * @return
				 */
				public static Car getCar( String name ) {
					
					return cars.get(name);
				}
				
				
				public static void main(String[] args) {
					
					ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-factory.xml");
					
					Car car1 = (Car) ctx.getBean("car1");
					System.out.println( car1 );
				}
			}
			
		2.通过调用实例工厂方法创建 Bean
		 1.实例工厂方法: 将对象的创建过程封装到另外一个对象实例的方法里. 当客户端需要请求对象时, 只需要简单的调用该实例方法而不需要关心对象的创建细节.
		 	
		 	要声明通过实例工厂方法创建的 Bean
					在 bean 的 factory-bean 属性里指定拥有该工厂方法的 Bean
					在 factory-method 属性里指定该工厂方法的名称
					使用 construtor-arg 元素为工厂方法传递方法参数
		 	
		 			<bean id="carFactory" class="com.atguigu.srping.beans.factory.InstanceCarFacory" 
		
					></bean>
					
					<bean id="car2" factory-bean="carFactory" factory-method="getCar">
						<constructor-arg value="audi"></constructor-arg>
					</bean>
				
				*
				 * 
				 * 实例工厂方法:实例工厂方法,即需要创建工厂本身,再调用工厂实例的方法来返回bean的实例
				 */
				public class InstanceCarFacory {
				
					private Map<String , Car > cars = null;
					
					public InstanceCarFacory() {
						
						cars = new HashMap<String , Car>();
						cars.put("audi", new Car( "audi" , 300000 , 28) );
						cars.put("fute", new Car( "fute" , 400000 , 28) );
						
					} 
					
					public Car getCar( String name ) {
						
						return cars.get( name );
					}
					
				}
				
			3.通过FactoryBean配置
			
			1.实现 FactoryBean 接口在 Spring IOC 容器中配置 Bean
				
				工厂 Bean 跟普通Bean不同, 其返回的对象不是指定类的一个实例, 
				其返回的是该工厂 Bean 的 getObject 方法所返回的对象 
				
		
		
	基于注解的方式配置bean
	
		配置形式：基于 XML 文件的方式；基于注解的方式（基于注解配置 Bean；基于注解来装配 Bean 的属性）
		
		
		1.在 classpath 中扫描组件
			组件扫描(component scanning):  Spring 能够从 classpath 下自动扫描, 侦测和实例化具有特定注解的组件.
			
			特定组件包括:
				@Component: 基本注解, 标识了一个受 Spring 管理的组件
				@Respository: 标识持久层组件
				@Service: 标识服务层(业务层)组件
				@Controller: 标识表现层组件
				
		对于扫描到的组件, Spring 有默认的命名策略: 使用非限定类名, 
		第一个字母小写. 也可以在注解中通过 value 属性值标识组件的名称
	
		在 classpath 中扫描组件
			
					当在组件类上使用了特定的注解之后, 还需要在 Spring 的配置文件中声明 <context:component-scan> ：
						base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包里及其子包中的所有类. 
						当需要扫描多个包时, 可以使用逗号分隔.
						如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类，示例：
					
					<context:include-filter> 子节点表示要包含的目标类
					<context:exclude-filter> 子节点表示要排除在外的目标类
					<context:component-scan> 下可以拥有若干个 <context:include-filter> 和 <context:exclude-filter> 子节点
			
			
				
	<!-- 指定Spring IOC 容器扫描的包 -->
	<!-- resource-pattern 指定扫描的资源 -->
	<context:component-scan base-package="com.atguigu.srping.beans.annotation"
	resource-pattern="repository/*.class"
	
	>
	</context:component-scan>
	
			<!-- annotation -->
		<!-- 指定排除那些制定表达式的组件
		annotation:根据注解
		 -->
	<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/>	
				
				
				
		<!--context:include-filter:子节点指定包含哪些表达式的组件,该子节点需要use-default-filters配合使用
	  -->
	<context:component-scan base-package="com.atguigu.srping.beans.annotation"
	 use-default-filters="false">
		<context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/>
	</context:component-scan>
	
	
	
	<!--context:exclude-filter:
		
		type="assignable" 
		指定所有继承或实现expression所指的类
	
	  -->
	<context:component-scan base-package="com.atguigu.srping.beans.annotation"
	>
	
		<context:exclude-filter type="assignable" expression="com.atguigu.srping.beans.annotation.repository.UserRepository"/>
	
	</context:component-scan>
		
		
		
	组件装配
	
	<context:component-scan> 元素还会自动注册 AutowiredAnnotationBeanPostProcessor 实例, 
	该实例可以自动装配具有 @Autowired 和 @Resource 、@Inject注解的属性.
	
	Autowired:注解自动装配具有兼容类型的单个 Bean属性
	
				1.构造器, 普通字段(即使是非 public), 一切具有参数的方法都可以应用@Authwired 注解
				
				2.默认情况下, 所有使用 @Authwired 注解的属性都需要被设置. 
					当 Spring 找不到匹配的 Bean 装配属性时, 会抛出异常, 若某一属性允许不被设置, 
					可以设置 @Authwired 注解的 required 属性为 false
				3.默认情况下, 当 IOC 容器里存在多个类型兼容的 Bean 时, 通过类型的自动装配将无法工作. 此时可以在 @Qualifier
				 注解里提供 Bean 的名称. Spring 允许对方法的入参标注 @Qualifiter 已指定注入 Bean 的名称
				
				4. @Authwired 注解也可以应用在数组类型的属性上, 此时 Spring 将会把所有匹配的 Bean 进行自动装配.
				
				5.@Authwired 注解也可以应用在集合属性上, 此时 Spring 读取该集合的类型信息, 然后自动装配所有与之兼容的 Bean.
				
				6.@Authwired 注解用在 java.util.Map 上时, 若该 Map 的键值为 String, 
				那么 Spring 将自动装配与之 Map 值类型兼容的 Bean, 此时 Bean 的名称作为键值
				
			使用 @Resource 或 @Inject 自动装配 Bean
			
				Spring 还支持 @Resource 和 @Inject 注解，这两个注解和 @Autowired 注解的功用类似
				@Resource 注解要求提供一个 Bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称
				@Inject 和 @Autowired 注解一样也是按类型匹配注入的 Bean， 但没有 reqired 属性
				建议使用 @Autowired 注解
				
		泛型依赖注入:
			1.Spring 4.x 中可以为子类注入子类对应的泛型类型的成员变量的引用
			
				
			public class BaseService<T> {
			
				@Autowired
				protected BaseRepository<T> repository;
				
				public void add() {
					
					System.out.println( "add ... ");
					System.out.println(  repository  );
				}
			}
				
			public class BaseRepository<T>{
			
			}
			
			
			@Repository
			public class UserRepository extends BaseRepository<User>{

			}
			
			
			@Service
			public class UserService  extends  BaseService<User>{
			
			}
			
			public class Main {

	
			public static void main(String[] args) {
				
				
				ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-generic-di.xml");
				
				UserService userService = (UserService) ctx.getBean("userService");
				
				userService.add();
				
			}
		}
			
			<context:component-scan base-package="com.atguigu.srping.beans.generic.di"
		>
	</context:component-scan>	
	
	
	以上可以知道泛型依赖注入
		UserRepository  父类 中BaseRepository<T> repository 变量会根据BaseService<User> 的泛型
		类型注入BaseRepository<User>的子类
		
		Spring 允许通过 <import> 将多个配置文件引入到一个文件中，进行配置文件的集成。这样在启动 Spring 容器时，仅需要指定这个合并好的配置文件就可以。
		import 元素的 resource 属性支持 Spring 的标准的路径资源
		
		地址前缀:classpath: 从类路径下加载资源
				file:	从文件系统加载资源
				http:// 从web服务器加载资源
				ftp://  从ftp加载资源
	spring AOP:
		
		AOP(Aspect-Oriented Programming, 面向切面编程): 是一种新的方法论, 
				是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充.
			AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点.
			
			在应用 AOP 编程时, 仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 
			这样一来横切关注点就被模块化到特殊的对象(切面)里.
			
		AOP 的好处:
				每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级
				业务模块更简洁, 只包含核心业务代码.
		
	AOP 术语	
	
		切面(Aspect):  横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象,就是整个横切面对象
		通知(Advice):  切面必须要完成的工作,横切面的方法
		
		目标(Target): 被通知的对象,要横切的对象
		
		代理(Proxy): 向目标对象应用通知之后创建的对象，切面和目标组成的对象
		
		连接点（Joinpoint）：程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。
			连接点由两个信息确定：方法表示的程序执行点；相对点表示的方位。目标的方法及方法前还是方法后
			例如 ArithmethicCalculator#add() 方法执行前的连接点，执行点为 ArithmethicCalculator#add()； 方位为该方法执行前的位置
		
		
		切点（pointcut）：每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点，即连接点是程序类中客观存在的事务。
			AOP 通过切点定位到特定的连接点。
			类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，
			切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。
			具体的连接点

		
		Spring  AOP
		
			AspectJ：Java 社区里最完整最流行的 AOP 框架.
			在 Spring2.0 以上版本中, 可以使用基于 AspectJ 注解或基于 XML 配置的 AOP
			
		在 Spring 中启用 AspectJ 注解支持	
			
			要在 Spring 应用中使用 AspectJ 注解, 必须在 classpath 下包含 AspectJ 类库: aopalliance.jar、aspectj.weaver.jar 和 spring-aspects.jar
			将 aop Schema 添加到 <beans> 根元素中.
			要在 Spring IOC 容器中启用 AspectJ 注解支持, 只要在 Bean 配置文件中定义一个空的 XML 元素 <aop:aspectj-autoproxy>
			当 Spring IOC 容器侦测到 Bean 配置文件中的 <aop:aspectj-autoproxy> 元素时, 会自动为与 AspectJ 切面匹配的 Bean 创建代理.
			
					<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt -->
			<dependency>
			    <groupId>org.aspectj</groupId>
			    <artifactId>aspectjrt</artifactId>
			    <version>1.9.2</version>
			</dependency>
					<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
			<dependency>
			    <groupId>org.aspectj</groupId>
			    <artifactId>aspectjweaver</artifactId>
			    <version>1.9.2</version>
			</dependency>
		
			
			1.Spring的Aop需要加入jar包
				core ,beans. context, expression ,commons-loging,
				spring-aop,aspectjweaver,aspectjrt	
				
			2.在配置文件中加入aop的命名空间
				
			3.基于注解的方式
				1.在配置文件中加入如下配置
					<!-- 使AspjectJ注解起作用:自动为匹配的类生成代理对象 -->
					<aop:aspectj-autoproxy proxy-target-class="true"></aop:aspectj-autoproxy>
					
				2.把横切关注点的代码抽象到切面的类中
					1.切面首先是一个ioc的bean，即加入@Component注解
					2.切面还要加入注解@Aspect
				
				3.在类中声明各种通知
					AspectJ 支持 5 种类型的通知注解: 
					@Before: 前置通知, 在方法执行之前执行
					@After: 后置通知, 在方法执行之后执行 
					@AfterRunning: 返回通知, 在方法返回结果之后执行
					@AfterThrowing: 异常通知, 在方法抛出异常之后
					@Around: 环绕通知, 围绕着方法执行
					1.声明一个方法
					2.在方法前加入@Before注解
					 
					利用方法签名编写 AspectJ 切入点表达式
					可以在通知方法中声明一个类型为 JoinPoint 的参数. 然后就能访问链接细节. 如方法名称和参数值.
					
						@Component
				public class AtithmeticCalculatorImpl implements AtithmeticCalculator {
				
					public int add(int i, int j) {
						
						int result = i + j;
						return result ;
					}
				
					public int sub(int i, int j) {
						int result = i - j;
						return result;
					}
				
					public int mul(int i, int j) {
						int result = i * j; 
						return result;
					}
				
					public int div(int i, int  j ) {
						int result = i / j; 
						return result;
					}
				
				}
				
				
				//这个类声明为一个切面
				//1.需要把该类放入ioc容器中
				//2.声明为一个切面
				@Aspect
				@Component
				public class LoggingAspect {
				
					public LoggingAspect() {
						// TODO Auto-generated constructor stub
					}
					
					//声明该方法为一个前置通知，在目标方法开始之前执行
					@Before("execution( public int com.atguigu.spring.aop.impl.AtithmeticCalculatorImpl.*(int, int) )")
					public void before( JoinPoint jPoint) {
						
						String methodName = jPoint.getSignature().getName();
						List<Object> args = Arrays.asList( jPoint.getArgs() );
						System.out.println( "the method "+ methodName + " befores with " + args );
					}
					
				}
				
	
	后置通知:
		//后置通知:在目标方法执行后(无论是否发生异常),执行通知
	//在后置通知中还不能访问目标方法执行的结果
	@After("execution( public int com.atguigu.spring.aop.impl.AtithmeticCalculatorImpl.*(int, int) )")
	public void afterMethod( JoinPoint joinPoint ) {
		
		String methodName = joinPoint.getSignature().getName();
		List<Object> args = Arrays.asList( joinPoint.getArgs() );
		System.out.println( "the method "+ methodName + " ends with " + args );
	}
		
		
	利用方法签名编写 AspectJ 切入点表达式
	
	execution * com.atguigu.spring.ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中声明的所有方法,第一个 * 代表任意修饰符及任意返回值. 第二个 * 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名.
	execution public * ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 接口的所有公有方法.
	execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法
	execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数
	execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法.
	
	
	返回通知:
	
		/**
	 * 在方法正常执行后执行的代码
	 * 返回通知是可以访问到方法的返回值的
	 * @param jPoint
	 */
	@AfterReturning(returning="result" , pointcut="execution( public int com.atguigu.spring.aop.impl.AtithmeticCalculatorImpl.*(..) )")
	public void afterReturning( JoinPoint jPoint , Object result) {
		
		String methodName = jPoint.getSignature().getName();
		List<Object> args = Arrays.asList( jPoint.getArgs() );
		System.out.println( "the method "+ methodName + " ends with " + result  );
	}
	
	
	
	/**
	 * 在目标方法出现异常的时候会执行的代码
	 * 可以访问到异常对象
	 * 可以指定在出现特定异常再执行通知代码
	 * @param joinPoint
	 * @param ec
	 */
	@AfterThrowing(throwing="ec" , pointcut="execution( public int com.atguigu.spring.aop.impl.AtithmeticCalculatorImpl.*(..) )")
	public void AfterThrowing( JoinPoint joinPoint , Exception ec ) {
		
		String methodName = joinPoint.getSignature().getName();
		
		System.out.println( "the method "+ methodName + " occurs exception " + ec.getStackTrace()  );
		
		try {
			
		} catch (Exception ex) {
			// TODO: handle exception
		}
	}
	
	
		/**
	 * 环绕通知需要携带ProceedingJoinPoint类型的参数
	 * 环绕通知类似动态代理全过程:ProceedingJoinPoint类型的参数可以决定是否执行目标方法
	 *且环绕通知必须由返回值,返回值就是目标方法的返回值
	 * @param point
	 * @throws Throwable 
	 */
	@Around("execution( public int com.atguigu.spring.aop.impl.AtithmeticCalculatorImpl.*(..) )")
	public Object aroundMethod( ProceedingJoinPoint point ) throws Throwable {
		
		
		String methodName = point.getSignature().getName();
		Object o = point.proceed();
		System.out.println( "the method "+ methodName + " occurs exception " );;
		return o;
	}
	
	
	/** 
	 * 环绕通知需要携带ProceedingJoinPoint类型的参数
	 * 环绕通知类似动态代理全过程:ProceedingJoinPoint类型的参数可以决定是否执行目标方法
	 *且环绕通知必须由返回值,返回值就是目标方法的返回值
	 * @param point
	 * @throws Throwable 
	 */
	@Around("execution( public int com.atguigu.spring.aop.impl.AtithmeticCalculatorImpl.*(..) )")
	public Object aroundMethod( ProceedingJoinPoint point )  {
		
		Object result = null;
		
		String methodName= point.getSignature().getName();
		
		try {
			//前置通知
			System.out.println( "the method " + methodName + "begins with " + Arrays.asList(point.getArgs()));
			result = point.proceed();
			//返回通知
			System.out.println( "the method " + methodName + "ends with " + Arrays.asList(point.getArgs()));
		} catch (Throwable e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			
			//异常通知
		}
	
	//	后置通知
		return result;
	}	
	
	
	可以使用@Order(3)指定切面的优先级 值越小优先级越高	
	
				
					
	@Order(3)
	@Aspect
	@Component
	public class VlidationAspect {	
	
	
	重用切面表达式:
	
		使用@Pointcut来声明切入点表达式.
	
		@Order(2)
		@Aspect
		@Component
		public class LoggingAspect {
		
			final String str = "execution( public int com.atguigu.spring.aop.impl.AtithmeticCalculatorImpl.*(int, int) )";
			
			
			public LoggingAspect() {
				// TODO Auto-generated constructor stub
			}
			
			
			/**
			 * 定义一个方法用于声明切入点表达式.一般的该方法不需要再添入其他表达式
			 */
			@Pointcut("execution( public int com.atguigu.spring.aop.impl.AtithmeticCalculatorImpl.*(int, int) )")
			public void declareJoinPointExpression() {
				
				
			}
			
			//声明该方法为一个前置通知，在目标方法开始之前执行
			@Before("declareJoinPointExpression()")
			public void before( JoinPoint jPoint) {
				
				String methodName = jPoint.getSignature().getName();
				List<Object> args = Arrays.asList( jPoint.getArgs() );
				System.out.println( "the method "+ methodName + " befores with " + args );
			}
		}
		
		@Order(3)
		@Aspect
		@Component
		public class VlidationAspect {
		
			public VlidationAspect() {
				// TODO Auto-generated constructor stub
			}
		
			@Before("LoggingAspect.declareJoinPointExpression())")
			public void volidateArgas( JoinPoint  joinPoint ) {
				
				System.out.println( " volidate: " + Arrays.asList( joinPoint.getArgs() ) );
			}
			
		}
		
		
	基于配置文件的方式:
	
	<bean id="atithmeticCalculatorImpl" class="com.atguigu.spring.aop.xml.AtithmeticCalculatorImpl">
		
	</bean>
	
	<!-- 配置切面的bean -->
	<bean id="loggingAspect" class="com.atguigu.spring.aop.xml.LoggingAspect"></bean>
	<bean id="vlidationAspect" class="com.atguigu.spring.aop.xml.VlidationAspect"></bean>
	
	<aop:config proxy-target-class="true">
		<aop:pointcut expression="execution(*  com.atguigu.spring.aop.xml.AtithmeticCalculator.*(..))" 
		id="pointcut"/>
		<!-- 配置切面及通知 -->
		<aop:aspect ref="loggingAspect" order="2">
			<aop:before method="before" pointcut-ref="pointcut"/>
			<aop:after method="afterMethod" pointcut-ref="pointcut"/>
			<aop:after-returning method="afterReturning" pointcut-ref="pointcut" returning="ret"/>
		</aop:aspect> 
		<aop:aspect ref="vlidationAspect" order="1">
			<aop:before method="volidateArgas" pointcut-ref="pointcut"/>
		</aop:aspect>
	</aop:config>
	
	
Spring 对 JDBC 的支持
  	
  	JdbcTemplate 简介
  	
  	为了使 JDBC 更加易于使用, Spring 在 JDBC API 上定义了一个抽象层, 以此建立一个 JDBC 存取框架.
  	
	作为 Spring JDBC 框架的核心, JDBC 模板的设计目的是为不同类型的 JDBC 操作提供模板方法. 
	每个模板方法都能控制整个过程, 并允许覆盖过程中的特定任务. 
	通过这种方式, 可以在尽可能保留灵活性的情况下, 将数据库存取的工作量降到最低.
	
	
	两种方式使用jdbcTemplate 一个是作为成员变量  一个是继承JdbcDaoSupport 推荐使用前者简单易用
  	
	package com.atguigu.spring.jdbc;
	
	
	
	<context:property-placeholder location="classpath:db.properties"/>
	
	<!-- 配置c3po数据源 -->
	<bean  id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="user" value="${jdbc.user}"></property>
		<property name="password" value="${jdbc.password}"></property>
		<property name="jdbcUrl" value="${jdbc.url}"></property>
		<property name="driverClass" value="${jdbc.driver}"></property>
		<property name="initialPoolSize" value="${jdbc.initPoolSize}"></property>
		<property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property>
	</bean>
	
	
	<!-- 配置spring的jdbcTemplate -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import javax.sql.DataSource;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

public class JdbcTest {
	
	private ApplicationContext ctx = null;	
	private JdbcTemplate jdbcTemplate = null;
	
	
	{
		ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
		jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate");
	}
	
	public JdbcTest() {
		// TODO Auto-generated constructor stub
	}
	
	
	/*
	 * 从数据库中获取一条数据实际获取一个对象
	 * 注意:不是调用这个方法public <T> T queryForObject(String sql, Object[] args, Class<T> requiredType)
	 * 而是它:public <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)
	 * 
	 * 1.其中RowMapper指定如何去映射结果集的行,常用的实现类BeanPropertyRowMapper
	 * 2.需要使用sql中列的别名和类的属性名的映射
	 * 3.不支持级联属性.jdbcTemplate 到底是一个jdbc的小工具而不是orm框架
	 */
	@Test
	public void testQueryForObject( ) {
		
		String sql = "select id, name , salary , email ,dept_id 'dept.id' from employee where id=?";
		RowMapper<Employee> rowMapper = new BeanPropertyRowMapper<>(Employee.class);
		Employee employee = jdbcTemplate.queryForObject( sql,  rowMapper , 1 );
		System.out.println( employee );
		
	}
	
	/**
	 * 获取单个列的值
	 * 
	 */
	@Test
	public void testQueryForObject2( ) {
		
		String sql = "select count(id) from employee";
		RowMapper<Employee> rowMapper = new BeanPropertyRowMapper<>(Employee.class);
		long count = jdbcTemplate.queryForObject(sql, Long.class);
		System.out.println( count );
		
	}
	
	@Test
	public void testQueryForList() {
		
		String sql = "select id, name , salary , email  from employee";
		RowMapper<Employee> rowMapper = new BeanPropertyRowMapper<>(Employee.class);
		List<Employee > employees = jdbcTemplate.query(sql, rowMapper);
		System.out.println( employees );
	}
	
	@Test
	public void testBatchUpdate() {
		
		String sql = "insert into employee(name,salary,email,dept_id) values(?,?,?,?)";
		List<Object[]> batchArgs = new ArrayList<>();
		
		batchArgs.add(new Object[]{"AA" , 103.4 , "aa@atguigu.com" ,1 } );
		batchArgs.add(new Object[]{"BB" , 103.4 , "bb@atguigu.com" ,1 } );
		batchArgs.add(new Object[]{"CC" , 103.4 , "cc@atguigu.com" ,1 } );
		jdbcTemplate.batchUpdate(sql, batchArgs);
	}
	
	@Test
	public void testUpdate() {
		
		String sql = "update employee set name=? where id=?";
		jdbcTemplate.update(sql, "zhao" , 1);
		
	}
	
	@Test
	public void test( ) {
		
		DataSource dataSource = (DataSource) ctx.getBean("dataSource");
		try {
			System.out.println( dataSource.getConnection() );
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

在 JDBC 模板中使用具名参数
	在经典的 JDBC 用法中, SQL 参数是用占位符 ? 表示,并且受到位置的限制. 定位参数的问题在于, 一旦参数的顺序发生变化, 就必须改变参数绑定. 
	在 Spring JDBC 框架中, 绑定 SQL 参数的另一种选择是使用具名参数(named parameter). 
	具名参数: SQL 按名称(以冒号开头)而不是按位置进行指定. 具名参数更易于维护, 也提升了可读性. 具名参数由框架类在运行时用占位符取代
	具名参数只在 NamedParameterJdbcTemplate 中得到支持

	<bean id="name" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
		<constructor-arg name="dataSource" ref="dataSource"></constructor-arg>
	</bean>

	
		/**
	 * 可以给参数起名字 
	 * 
	 * 好处若有多个参数则不用再去对应位置,直接对应参数名字便于维护
	 * 缺点是较为麻烦
	 */
	@Test
	public void testNamedParameterJdbcTemplate() {
		
		String sql = "insert into employee(name,salary,email,dept_id) values(:name,:salary,:email,:deptid)";
		
		Map<String,Object> paramMap = new HashMap<>();
		paramMap.put("name", "FF");
		paramMap.put("salary", 12000.5);
		paramMap.put("email", "ff@atguigu.com");
		paramMap.put("deptid", 1);
		namedParameterJdbcTemplate.update(sql, paramMap);
	}
	
	
	/**
	 * sql语句中的参数名和类的属性一致
	 * 使用sqlParameterSource的BeanPropertySqlParameterSource实现类作为类参数
	 */
	@Test
	public void testNamedParameterJdbcTemplate2() {
		
		String sql = "insert into employee(name,salary,email,dept_id) values(:name,:salary,:email,:deptId)";
		
		Employee employee = new Employee();
		employee.setName("XYZ");
		employee.setEmail("xyz@sina.com");
		employee.setDeptId(3);
		
		SqlParameterSource source = new BeanPropertySqlParameterSource(employee);
		namedParameterJdbcTemplate.update(sql, source);
	}
	
	
	Spring的事务管理(开发的时候必用的一个功能)
			
	事务简介
	
		事务管理是企业级应用程序开发中必不可少的技术,  用来确保数据的完整性和一致性. 
		事务就是一系列的动作, 它们被当做一个单独的工作单元. 这些动作要么全部完成, 要么全部不起作用
		
		事务的四个关键属性(ACID)
		原子性(atomicity): 事务是一个原子操作, 由一系列动作组成. 事务的原子性确保动作要么全部完成要么完全不起作用.
		一致性(consistency): 一旦所有事务动作完成, 事务就被提交. 数据和资源就处于一种满足业务规则的一致性状态中.
		隔离性(isolation): 可能有许多事务会同时处理相同的数据, 因此每个事物都应该与其他事务隔离开来, 防止数据损坏.
		持久性(durability): 一旦事务完成, 无论发生什么系统错误, 它的结果都不应该受到影响. 通常情况下, 事务的结果被写到持久化存储器中.
	
	
	Spring 中的事务管理
	
		作为企业级应用程序框架, Spring 在不同的事务管理 API 之上定义了一个抽象层. 
			而应用程序开发人员不必了解底层的事务管理 API, 就可以使用 Spring 的事务管理机制.
			
		Spring 既支持编程式事务管理, 也支持声明式的事务管理. 
		
		编程式事务管理: 将事务管理代码嵌入到业务方法中来控制事务的提交和回滚.
			 在编程式管理事务时, 必须在每个事务操作中包含额外的事务管理代码. 
			 
		声明式事务管理: 大多数情况下比编程式事务管理更好用. 它将事务管理代码从业务方法中分离出来, 
			以声明的方式来实现事务管理. 事务管理作为一种横切关注点, 可以通过 AOP 方法模块化. 
			Spring 通过 Spring AOP 框架支持声明式事务管理.
			
	Spring 中的事务管理器
		
		Spring 从不同的事务管理 API 中抽象了一整套的事务机制. 
			开发人员不必了解底层的事务 API, 就可以利用这些事务机制. 有了这些事务机制, 
				事务管理代码就能独立于特定的事务技术了.
		
		Spring 的核心事务管理抽象是       Interface Platform TransacationManager              
			它为事务管理封装了一组独立于技术的方法. 
			无论使用 Spring 的哪种事务管理策略(编程式或声明式), 事务管理器都是必须的.
			
	
		Spring 中的事务管理器的不同实现:
			对于Jta 是JtaTransacationManager
			对于Hibernate 是 HibernateTransacationManager
			jdbc : DataSourceTransacationManager
			
	1.注解式事务配置 Spring的声明式的事务:
		1.添加事务管理器
			
		<!-- 配置事务管理器 -->
		<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<property name="dataSource" ref="dataSource"></property>
		 </bean>
		 
		 <!-- 启用事务注解 -->
		 <tx:annotation-driven transaction-manager="transactionManager"/>
		 
		2.给方法添加注解
		
			//添加事务注解
			@Transactional
			@Override
			public void purchase(String username, String isbn) {
				
				int price = bookShopDao.findBookPriceByIsbn(isbn);
				bookShopDao.updateBookStock(isbn);
				bookShopDao.updateUserAccount(username, price );
				
			}
	
		3.
		
		除了在带有切入点, 通知和增强器的 Bean 配置文件中声明事务外, Spring 还允许简单地用 @Transactional 注解来标注事务方法. 
		
		为了将方法定义为支持事务处理的, 可以为方法添加 @Transactional 注解. 根据 Spring AOP 基于代理机制, 只能标注公有方法.
		
		可以在方法或者类级别上添加 @Transactional 注解. 当把这个注解应用到类上时, 这个类中的所有公共方法都会被定义成支持事务处理的. 
		
		在 Bean 配置文件中只需要启用 <tx:annotation-driven> 元素, 并为之指定事务管理器就可以了. 
		
		如果事务处理器的名称是 transactionManager, 就可以在<tx:annotation-driven> 元素中省略 transaction-manager 属性.
		 这个元素会自动检测该名称的事务处理器.
		
		
	事务传播属性
	
		当事务方法被另一个事务方法调用时, 必须指定事务应该如何传播. 
			例如: 方法可能继续在现有事务中运行, 也可能开启一个新事务, 并在自己的事务中运行.
		事务的传播行为可以由传播属性指定. Spring 定义了 7  种类传播行为.
			
		 举个例子:就是你在饭馆吃饭遇见了自己的同学,是要和他们一起吃还是另外要开一桌
		 当以个事务方法调用另外一个事物方法的时候是新开一个事务还是在原来的事务中运行
		 
		 
		*REQUIRED:如果有事务在运行,当前的方法就在这个事物中运行,否则就启动一个新的事务
		*REQUIRED_NEW:当前的方法必须启动新事物,并在它自己的事务中运行,如果有事务在运行,应该将它挂起
		*SUPPORTS:如果有事务在运行,当前的方法就在这个事物中运行,否则它可以不在事务的运行中
		NOT_SUPPORTS:当前方法不在事务中运行,如果有运行的事务,将它挂起
		MANDATORY:当前方法必须运行在事务内部,如果没有运行的事务就将抛出异常
		NEVER:当前方法不应该运行在事务中,如果有运行的事务就跑出异常
		NESTED:如果有事务运行,当前的方法就应该在这个事务的嵌套事务内运行,否则就启动一个新的事务,并在它自己的事务内运行
		
		
			/**
		 * 添加事务注解
		 * 使用Propagation指定事务的传播行为,即当前的事务方法被另外一个事物方法调用时如何如何使用事务
		 * 默认取值为Propagation.REQUIRED,及使用调用方法的事务
		 * Propagation.REQUIRES_NEW:事务自己的事务,调用的事务方法的事务被挂起
		 */
		@Transactional(propagation=Propagation.REQUIRES_NEW)
		@Override
		public void purchase(String username, String isbn) {
			
			int price = bookShopDao.findBookPriceByIsbn(isbn);
			bookShopDao.updateBookStock(isbn);
			bookShopDao.updateUserAccount(username, price );
			
		}
		
	
			REQUIRED 传播行为	
	
		 	当 bookService 的 purchase() 方法被另一个事务方法 checkout() 调用时, 
		 	它默认会在现有的事务内运行. 这个默认的传播行为就是 REQUIRED. 因此在 checkout() 方法的开始和终止边界内只有一个事务. 
		 	这个事务只在 checkout() 方法结束的时候被提交, 结果用户一本书都买不了
		 	
			事务传播属性可以在 @Transactional 注解的 propagation 属性中定义
		 	
			REQUIRES_NEW 传播行为
			
			另一种常见的传播行为是 REQUIRES_NEW. 它表示该方法必须启动一个新事务, 并在自己的事务内运行. 
			如果有事务在运行, 就应该先挂起它.
			
	并发事务所导致的问题
			
		当同一个应用程序或者不同应用程序中的多个事务在同一个数据集上并发执行时, 可能会出现许多意外的问题
		并发事务所导致的问题可以分为下面三种类型:
		
		脏读: 对于两个事物 T1, T2, T1  读取了已经被 T2 更新但 还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的.
		
		不可重复读:对于两个事物 T1, T2, T1  读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.
		
		幻读:对于两个事物 T1, T2, T1  从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 
		就会多出几行.
			
		事务的隔离级别
			从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题. 然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行. 
			在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行.
			事务的隔离级别可以通过隔离事务属性指定
		
		DEFAULT:使用底层数据库默认的隔离级别,对于大多数的数据来说,默认隔离级别都是READ_COMMITED;
		READ_UNCOMMITED:允许事务读取被其他事务提交的更新,脏读,不可重复读和幻读的问题都会出现
		READ_COMMITED:只允许事务读取其他事务已经提交的数据,可以避免脏读,但不重复读和幻读会出现
		REPEATEABLE_READ:确保事务可以多次从一个字段读取相同的值.在这个事务持续期间,禁止其他事务对这个字段进行更新,可以避免脏读
		和重复读,当幻读问题仍然存在
		SERIALIZABLE:确保事务可以从一个表中读取相同的行,在这个事务持续期间,禁止其他事务对该表执行插入,更新,删除操作,所有并发问题都可以
		避免当时效率低下
		
		事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.
			Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE
			Mysql 支持 4 中事务隔离级别.
		
					/**
			 * 添加事务注解
			 * 使用Propagation指定事务的传播行为,即当前的事务方法被另外一个事物方法调用时如何如何使用事务
			 * 默认取值为Propagation.REQUIRED,及使用调用方法的事务
			 * Propagation.REQUIRES_NEW:事务自己的事务,调用的事务方法的事务被挂起
			 * 使用isolation:指定事务的隔离级别,
			 * 最常用的值为Isolation.READ_COMMITTED 
			 */
			@Transactional(propagation=Propagation.REQUIRES_NEW
					,isolation=Isolation.READ_COMMITTED)
			@Override
			public void purchase(String username, String isbn) {
				
				int price = bookShopDao.findBookPriceByIsbn(isbn);
				bookShopDao.updateBookStock(isbn);
				bookShopDao.updateUserAccount(username, price );
				
			}
		
		
		事务的相关的属性详解:
		
		Service("bookShopService")
		public class BookShopServiceImpl implements BookShopService{
		
			@Autowired
			BookShopDao bookShopDao;
		
			/**
			 * 添加事务注解
			 * 
			 * 1.使用Propagation指	定事务的传播行为,即当前的事务方法被另外一个事物方法调用时如何如何使用事务
			 * 默认取值为Propagation.REQUIRED,及使用调用方法的事务
			 * Propagation.REQUIRES_NEW:事务自己的事务,调用的事务方法的事务被挂起
			 * 
			 * 2.使用isolation:指定事务的隔离级别,
			 * 最常用的值为Isolation.READ_COMMITTED 
			 * 
			 * 3.默认情况下午Spring的声明式的事务对所有的运行时异常进行回滚,也可以通过对对应的属性进行设置,通常默认值即可
			 * noRollbackFor={UserAccountException.class}
			 * 
			 * 4.只读属性readOnly
			 * 	指定事务是否为只读
			 * 	这个时候数据库引擎可以优化(只读事务)
			 * 	若真的是一个只读取数据库值的方法应设置readOnly=true
			 * 
			 * 5.timeout=1 使用timeout指定强制回滚之前事务可以占用的时间
			 */
			@Transactional(propagation=Propagation.REQUIRES_NEW
					,isolation=Isolation.READ_COMMITTED ,noRollbackFor={UserAccountException.class}
					,readOnly=false,timeout=3
					)
			@Override
			public void purchase(String username, String isbn) {
				
				try {
					Thread.sleep(5000);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				int price = bookShopDao.findBookPriceByIsbn(isbn);
				bookShopDao.updateBookStock(isbn);
				bookShopDao.updateUserAccount(username, price );
			}
		}
	
	基于XML的事务配置:
		
					
	1.
	<!-- 配置事务管理器 -->
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	 </bean>
	 
	2.
	<!-- 配置事务属性 -->
	<!--  tx:advice  指定事务的属性 和注解方法的Transcation注解的效果是一样的  -->
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 根据方法名指定事务的属性 -->
			<tx:method name="purchase" propagation="REQUIRES_NEW"/>
			<tx:method name="get*" read-only="true"  />
			<tx:method name="find*" read-only="true" />
			<tx:method name="*"  />
		</tx:attributes>
	</tx:advice>
	
	3.
	<!-- 事务的切点  配置事务的切入点 以及把事务切入点和事务管理-->
	<aop:config>
		<aop:pointcut expression="execution( * com.atguigu.spring.tx.xml.service.*.*(..) )" id="txpointCut"/>
		
		<!-- 将事务的属性和事务的切面联系起来 -->
		<aop:advisor advice-ref="txAdvice" pointcut-ref="txpointCut"/>
	</aop:config>	
	
	1.事务管理器
	2.事务属性
	3.将事务切面和事务的属性关联起来
	
	
	spring整合hibernate:
		
		
		