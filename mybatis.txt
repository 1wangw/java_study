mybatis

	以前使用的 jdbc - Dbutils(QueryRunner)- jdbcTemplate 这些只是工具
	
	以前 编写sql - > 预编译 -> 设置参数 -> 执行sql -> 封装结果
	
	1.工具 功能简单 考虑的不周到 sql语句编写在java代码中:硬编码 高耦合
	
	hibernate:全自动orm(object relation mapping)框架
		旨在消除sql	HQL
			导致无法优化sql
								这些是黑箱操作(jdbc的操作部分)
		javabean - 编写sql - > 预编译 -> 设置参数 -> 执行sql -> 封装结果 - DbRecods
		
	希望的效果是:
		sql语句交给开发人员编写,还希望sql不失去灵活性
		
	
	mybatis： 半自动框架,轻量级的框架
							jdbc  sql部分编写暴露了出来
		javabean - 编写sql - > 预编译 -> 设置参数 -> 执行sql -> 封装结果 - DbRecods
		
		sql与java编码分离 ; sql是开发人员编写控制的；
		只需要掌握好sql
		
	创建helloworld:
	导入包:
		  	<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
				<dependency>
				    <groupId>org.mybatis</groupId>
				    <artifactId>mybatis</artifactId>
				    <version>3.4.6</version>
				</dependency>
				
				<!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core -->
			<dependency>
			    <groupId>org.apache.logging.log4j</groupId>
			    <artifactId>log4j-core</artifactId>
			    <version>2.11.1</version>
			</dependency>
				
				<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
		<dependency>
		    <groupId>mysql</groupId>
		    <artifactId>mysql-connector-java</artifactId>
		    <version>5.1.38</version>
		</dependency>
		
	创建数据表：
	
	创建实体类
	
	根据官方文档实例创建mybatis配置文件
				<?xml version="1.0" encoding="UTF-8" ?>
		<!DOCTYPE configuration
		  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
		  "http://mybatis.org/dtd/mybatis-3-config.dtd">
		<configuration>
		  <environments default="development">
		    <environment id="development">
		      <transactionManager type="JDBC"/>
		      <dataSource type="POOLED">
		        <property name="driver" value="com.mysql.jdbc.Driver"/>
		        <property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>
		        <property name="username" value="root"/>
		        <property name="password" value="123456"/>
		      </dataSource>
		    </environment>
		  </environments>
		   <!--将我们写好的sql映射文件注册到全局配置文件中-->
		  <mappers>
		    <mapper resource="config/EmployeeMapper.xml"/>
		  </mappers>
		 
		</configuration>
		
	创建映射文件:
				<?xml version="1.0" encoding="UTF-8" ?>
		<!DOCTYPE mapper
		 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
		 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
		<mapper namespace="com.atguigu.mybatis.dao.EmployeeMapper">
		<!-- 
		namespace:名称空间;指定为接口的全类名 
		id：唯一标识
		resultType：返回值类型
		#{id}：从传递过来的参数中取出id值
		如果字段和属性不对应可以起别名
		public Employee getEmpById(Integer id);
		
		 -->
			<select id="selectEmp" resultType="com.atguigu.mybatis.bean.Employee">
				select id,last_name lastName,email,gender from tbl_employee where id = #{id}
			</select>
		</mapper>
		
	执行查询:
		/**
		 * 1.根据xml配置文件(全局配置文件)创建SqlSessionFactory
		 * 2.获取sqlSession 可以直接直接执行已经映射的sql语句
		 * 
		 * 
		 * @param args
		 * @throws IOException
		 */
		public static void main(String[] args) throws IOException {
				
			String resource = "config/mybatis-config.xml";
			InputStream inputStream = Resources.getResourceAsStream(resource);
			SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
			
			SqlSession sqlSession = sqlSessionFactory.openSession();
			// sql唯一标识 
			//sql要用的参数
			try{
				
				Employee employee = sqlSession.selectOne("com.atguigu.mybatis.dao.EmployeeMapper.selectEmp",1);
				System.out.println( employee );
				
			} finally {
				
				sqlSession.close();
			}
			
		}
		
	总结:
		/**
	 * 1.根据xml配置文件(全局配置文件)创建SqlSessionFactory
	 * 		有数据源一些运行环境信息
	 * 2.sql映射文件:配置了每一个sql,已经sql的封装规则
	 * 
	 * 3.将sql映射文件注册在全局配置文件中
	 * 
	 * 4.写代码
	 * 		1.首先根据全局配置文件获取SqlSessionFactory
	 * 		2.使用SqlSessionFactory获取到SqlSession
	 *		3.使用SqlSession执行增删该查,一个sqlSession代表和数据库的一次会话,用完关闭 
	 *		4.使用sql的唯一标志来告诉mybatis执行那个sql，sql都是保存在sql映射文件中的
	 * 
************************************************************************************
	上面的是mybatis以前的版本使用的方式:
	
	接口编程 拥有更强的类型检查
	
	HelloWorld-接口式编程:
	
		– 创建一个Dao接口 
			接口中查询方法和mapper文件的对应sql的id相同
			public interface EmployeeMapper {
	
				public Employee getEmpById(int id);
			}
			
		-修改Mapper文件
			mapper文件的namespace 和接口的类名相同
			
			<mapper namespace="com.atguigu.mybatis.dao.EmployeeMapper">
			<!-- 
			namespace:名称空间;指定为接口的全类名 
			id：唯一标识
			resultType：返回值类型
			#{id}：从传递过来的参数中取出id值
			
			如果字段和属性不对应可以起别名
			
			public Employee getEmpById(Integer id);
			 -->
				<select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee">
					select id,last_name lastName,email,gender from tbl_employee where id = #{id}
				</select>
			</mapper>
			
			
		–测试 
		
			public static  void test2() throws IOException  {
				
				String resource = "config/mybatis-config.xml";
				InputStream inputStream = Resources.getResourceAsStream(resource);
				SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
				
				SqlSession sqlSession = sqlSessionFactory.openSession();
				
				//获取接口的实现类
				//mybatis会为接口自动创建代理对象  代理对象执行增删改查
				EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
				Employee employee = mapper.getEmpById(1);
				
				System.out.println( employee );
				sqlSession.close();
			}
		
**************************************************************************	
	总结:
		1.接口式编程:
			原生:Dao -- DaoImpl
			mybatis ： Mapper ====>有一个与之对应的xxMapper.xml(namespace 和 接口名相同 )
		2.sqlSession 代表和数据库的一次会话:
			SqlSession 和Connect一样不是线程安全的，因此是不能被共享的。
			SqlSession每次使用关闭操作是必须关闭的
			SqlSession可以直接调用方法作，但是我们一般还是推荐使用到Dao接口的代理类，执行代理以更安全的进行类型检
		3.mapper接口没有实现类,但是mybatis会为这个接口生成一个代理对象
			(将接口和xml进行绑定)
			EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
			
		4.两个重要的配置文件:
			mybatis的全局配置文件：
				包含数据库连接池信息,事务管理器信息等等 系统运行环境的信息
			sql映射文件:
				保存了每一个sql的映射信息，将sql抽取出来 这个是hiberante 的区别
				
			
**********************************************************************************************
	
	MyBatis-全局配置文件:
	
		• MyBatis 的配置文件包含了影响 MyBatis 行为甚深的
			设置（settings）和属性（properties）信息。文档的
			顶层结构如下：
			• configuration 配置
			• properties 属性
			• settings 设置
			• typeAliases 类型命名
			• typeHandlers 类型处理器
			• objectFactory 对象工厂
			• plugins 插件
			• environments 环境
			• environment 环境变量
			• transactionManager 事务管理器
			• dataSource 数据源
			• databaseIdProvider 数据库厂商标识
			• mappers 映射器
	
		1.properties属性 (了解,因为 以后会使用spring管理)
				<!-- 
			mybatis可以使用<properties>标签引入外部的properties配置文件中的内容
				resource:引入类路径下的资源
				url：引入网络路径或磁盘路径下的资源文件	
			 -->
			<properties resource="config/dbconfig.properties" >
			</properties>
			
		2.settings设置
			这是 MyBatis 中极为重要的调整设置，它们会改变MyBatis 的运行时行为。
			*1.缓存全局开关默认是true
			<setting name="cacheEnabled" value="true" />
			
			*2.延迟加载全局开关
				值为 true 时所有对象延迟加载
				可通过在具体的查询中设置 fetchType 来覆盖该设置
				<setting name="lazyLoadingEnabled" value="false" />
			3.所有对象直接加载
				<setting name="aggressiveLazyLoading" value="true" />\
			4.允许单一语句返回多个结果集，需要兼容驱动	
				<setting name="multipleResultSetsEnabled" value="true" />
			*5.使用列标签代替类名
				<setting name="useColumnLabel" value="true" />
			6.允许 JDBC 使用数据库自增主键
				<setting name="useGeneratedKeys" value="true" />
			7.指定自动映射到字段的规则
				NONE 取消自动映射
				PARTIAL 只映射没有定义嵌套结果集映射的结果集
				FULL 自动映射任何结果集
				<setting name="autoMappingBehavior" value="PARTIAL" />
				
			8.指定当自动映射碰到未知列的处理规则
				NONE 不做任何处理
				WARNING 输入警告日志
				FAILING 抛出 SqlSessionException 异常
				<setting name="autoMappingUnknownColumnBehavior" value="NONE" />
			9.配置默认执行器
				SIMPLE 普通执行器
				REUSE 重用预处理语句
				BATCH 重用语句并执行批量更新
				<setting name="defaultExecutorType" value="SIMPLE" />
				
			*10.设置驱动等待数据库响应的超时时间
				该设置项默认没有值
				值的范围是任意正整数
				值的单位是秒
				<setting name="defaultStatementTimeout" value="" />
				
			11.为驱动的结果集数量设置提示值
				该设置项默认没有值
				值的范围是任意正整数
				可在具体查询中通过 fetchSize 覆盖该设置项
				<setting name="defaultFetchSize" value="" />
			12.允许在嵌套语句中使用分页 RowBounds
				<setting name="safeRowBoundsEnabled" value="false" />
			13.允许在嵌套语句中使用分页 RowHandler
				<setting name="safeRowHandlerEnabled" value="true" />
			**14.开启驼峰命令规则自动转换功能 
				例如：create_time > createTime
				<setting name="mapUnderscoreToCamelCase" value="false" />
			15.利用本地缓存机制防止循环引用和加速重复嵌套查询
				SESSION 缓存一个会话中执行的所有查询
				STATEMENT 本地会员只用在语句执行中，对相同 SqlSession 的不同调用不会共享数据
				<setting name="localCacheScope" value="SESSION" />
			16.当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型
				OTHER 一般类型
				NULL 空值
				VARCHAR 字符串
				<setting name="jdbcTypeForNull" value="OTHER" />
			17.指定某个对象的方法触发一次延迟加载
				多个方法名称通过逗号划分
				<setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString />"
			18.指定动态 SQL 生成的默认语言
				<setting name="defaultScriptingLanguage" value="org.apache.ibatis.scripting.xmltags.XMLLanguageDriver" />
			19.当结果集为 NULL 时，调用映射对象的 setter 方法为结果赋值
				结果集类型是 List 时，调用 setter 方法
				结果集类型是 Map 时，调用 put 方法
				该属性对于基本类型无效
			<setting name="callSetterOnNulls" value="false" />
			20.当对象所有列都返回 NULL 时，将整个对象设置为 NULL
			<setting name="returnInstanceForEmptyRow" value="false" />
			21.指定日志名称的前缀
				该设置项没有默认值
				值可以是任何字符串
			<setting name="logPrefix" value="" />
			22.指定日志的具体实现方式
				该设置项没有默认值
				值可以是 slf4j / log4j / log4j2 / jdk_logging / commons_logging / stdout_logging / no_loggging
				未指定值的时候会在上述支持列表中自动查找
				<setting name="logImpl" value="" />
				
			23.指定创建具有延迟加载能力的对象所用到的代理工具
				值可以是 CGLIB / JAVASSIST
				<setting name="proxyFactory" value="JAVASSIST" />
			24.指定 VFS 的实现
				该设置项没有默认值
				值可以是自定义 VFS 的实现类全名
				多个 VFS 可以通过逗号划分
				<setting name="vfsImpl" value="" />
			25.允许使用方法签名中的名称作为语句参数名称
				仅在 Java 8 环境中生效，并且需要在环境变量中加上 -parameters
				<setting name="useActualParamName" value="true" />

			<settings>
				  <setting name="cacheEnabled" value="true"/>
				  <setting name="lazyLoadingEnabled" value="true"/>
				  <setting name="multipleResultSetsEnabled" value="true"/>
				  <setting name="useColumnLabel" value="true"/>
				  <setting name="useGeneratedKeys" value="false"/>
				  <setting name="autoMappingBehavior" value="PARTIAL"/>
				  <setting name="autoMappingUnknownColumnBehavior" value="WARNING"/>
				  <setting name="defaultExecutorType" value="SIMPLE"/>
				  <setting name="defaultStatementTimeout" value="25"/>
				  <setting name="defaultFetchSize" value="100"/>
				  <setting name="safeRowBoundsEnabled" value="false"/>
				  <setting name="mapUnderscoreToCamelCase" value="false"/>
				  <setting name="localCacheScope" value="SESSION"/>
				  <setting name="jdbcTypeForNull" value="OTHER"/>
				  <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/>
			</settings>
					
				演示
					<!-- settings包含很多重要设置
					setting用来设置每一个设置项
						name:设置项名
						value:设置项取值
					常用配置 mapUnderscoreToCamelCase
				 -->
					<settings>
						<setting name="mapUnderscoreToCamelCase" value="true" />
					</settings>
			
		typeAliases别名处理器：
			1.类型别名是为 Java 类型设置一个短的名字，可以方便我们引用某个类。	
			2.类很多的情况下，可以批量设置别名这个包下的每一个类创建一个默认的别名，就是简单类名小写。
			3.也可以使用@Alias注解为其指定一个别名
			
			<!-- 别名处理器:
			1.可以为java类型起一个别名
			2.别名不区分大小写
		 -->
			<typeAliases>
				<!-- typeAlias:为某一个java类型起别名
						type:java类型  要起类型的全类名;默认别名是employee	
						alias:指定新的别名
					
				-->
				<!--  <typeAlias type="com.atguigu.mybatis.bean.Employee" alias="emp"/>
				-->
				<!-- 批量起别名package:可以为某个包下的所有类批量起别名  
						name:指定包名 (为当前包及其下面的后代包都起一个默认的别名(类名小写))
						如果包下有子包和父包中的类冲突 则可以在类名上通过@Alias("xx")起个别名
					-->
				<package name="com.atguigu.mybatis.bean"/>
			</typeAliases>
			
			值得注意的是，MyBatis已经为许多常见了相应的类型别名。它们都是大小写不敏别名的时候千万不要占用已有的别
			
				别名 映射的类型
					alias  Mapped Type
					_byte byte 
					_long long 
					_short short 
					_int int 
					_integer int 
					_double double 
					_float float 
					_boolean boolean 
					string String 
					byte Byte 
					long Long 
					short Short 
					int Integer 
					integer Integer 
					double Double 
					float Float 
					boolean Boolean 
					date Date 
					decimal BigDecimal 
					bigdecimal BigDecimal 
					object Object 
					map Map 
					hashmap HashMap 
					list List 
					arraylist ArrayList 
					collection Collection 
					iterator Iterator 
					
			虽然可以起别名但是建议使用全类名   可以更加情况的了解映射信息
			起的别名可以被resultType属性引用
			
	typeHandlers类型处理器:
		3.4以前的可以通过下载jar包 进行注册类型处理器 ,3.4以后的版本我们不用注册
		架起java类型和数据库类型的桥梁
		
		• 无论是 MyBatis 在预处理语句（PreparedStatement）中
			设置一个参数时，还是从结果集中取出一个值时， 都会
			用类型处理器将获取的值以合适的方式转换成 Java 类型。
			类型处理器 Java 类型 JDBC 类型
			BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN 
			ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE 
			ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SHORT INTEGER 
			IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER 
			LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 LONG INTEGER 
			FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT 
			DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE 
			BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL 
			StringTypeHandler java.lang.String CHAR, VARCHAR 
			
		<typeHandlers>
			<typeHandler handler="org.apache.ibatis.type.InstantTypeHandler' /> 
			<typeHandler handler="org.apache.ibatis.type.LocalDateTimeTypeHandler" /> 
			<typeHandler handler="org.apache.ibatis.type.LocalDateTypeHandler" /> 
			<typeHandler handler="org.apache.ibatis.type.LocalTimeTypeHandler/> 
			<typeHandler handler="org.apache.ibatis.type.OffsetDateTimeTypeHandler" /> 
			<typeHandler handler="org.apache.ibatis.type.OffsetTimeTypeHandlerM /> 
			<typeHandler handler="ong.apache.ibatis.type.ZonedDateTimeTypeHandlerM /> 
			<typeHandler handler="org.apache.ibatis.type.YearTypeHandlern /> 
			<typeHandler handler="org.apache.ibatis.type.MonthlypeHandler" /> 
			<typeHandler handler="org.apache.ibatis.type.YearMonthTypeHandler /> 
			<typeHandler handler="org.apache•ibatis.type.JapaneseDateTypeHandler" /> 
		</typeHandlers>
			
		日期类型的处理
			• 日期和时间的处理，JDK1.8以前一直是个头疼的
			问题。我们通常使用JSR310规范领导者Stephen 
			Colebourne创建的Joda-Time来操作。1.8已经实
			现全部的JSR310规范了。
			• 日期时间处理上，我们可以使用MyBatis基于
			JSR310（Date and Time API）编写的各种日期
			时间类型处理器。
			• MyBatis3.4以前的版本需要我们手动注册这些处
			理器，以后的版本都是自动注册的
			
	  	自定义类型处理器
			• 我们可以重写类型处理器或创建自己的类型处理
			器来处理不支持的或非标准的类型。
			• 步骤：
			• 1）、实现org.apache.ibatis.type.TypeHandler接口或
			者继承org.apache.ibatis.type.BaseTypeHandler
			• 2）、指定其映射某个JDBC类型（可选操作）
			• 3）、在mybatis全局配置文件中注册	
		
	plugins插件
		
		可以拦截sql语句的执行的步骤 其实就是一个动态代理的过程
		
		插件是MyBatis提供的一个非常强大的机制，我可以通过插件来修改MyBatis的一些核心行为。
		插件通过动态代理机制，可以介入四大对象的任何一个方法的执行。
		后面会有专门的章节我们来介绍mybatis运行原理以及插件
		
		这个就是四大对象及其方法
		
		Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
 		ParameterHandler (getParameterObject, setParameters) 
 		ResultSetHandler (handleResultSets, handleOutputParameters) 
		StatementHandler (prepare, parameterize, batch, update, query) 
		
		
	environments环境	
  	environments：环境们,mybatis可以配置多种环境，default指定使用某种环境，可以达到快速切换
			environment:配置一个具体的环境，必须有两个标签 id代表当前环境的唯一标识
				
				transactionManager（了解）：必须有,事务管理器(了解)
					实际开发中我们使用Spring管理数据源，并进行事务控制的配置来覆盖上述配置
					type:事务管理器的类型;取值其实是一个别名 通过Configration类中可以查看
						typeAliasRegistry.registerAlias("JDBC", JdbcTransactionFactory.class);
   					    typeAliasRegistry.registerAlias("MANAGED", ManagedTransactionFactory.class);
   					    
					  	取值:
							JDBC：使用了 JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务范围。
							
							MANAGED：不提交或回滚一个连接、让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 ManagedTransactionFactory
							自定义：实现TransactionFactory接口，type=全类名/别名
				dataSource（了解）：必须有
					type： UNPOOLED | POOLED | JNDI | 自定义
					– UNPOOLED：不使用连接池，UnpooledDataSourceFactory
					– POOLED：使用连接池， PooledDataSourceFactory
					– JNDI： 在EJB 或应用服务器这类容器中查找指定的数据源
					– 自定义：实现DataSourceFactory接口，定义数据源的获取方式。 type是全类名
					
					  typeAliasRegistry.registerAlias("JNDI", JndiDataSourceFactory.class);
   					  typeAliasRegistry.registerAlias("POOLED", PooledDataSourceFactory.class);
    				  typeAliasRegistry.registerAlias("UNPOOLED", UnpooledDataSourceFactory.class);
					<dataSource type="POOLED">
			        <property name="driver" value="${jdbc.driver}"/>
			        <property name="url" value="${jdbc.url}"/>
			        <property name="username" value="${jdbc.user}"/>
			        <property name="password" value="${jdbc.password}"/>
			      </dataSource>
					实际开发中我们使用Spring管理数据源，并进行事务控制的配置来覆盖上述配置
	
	databaseIdProvider环境：
		• MyBatis 可以根据不同的数据库厂商执行不同的语句
		• Type： DB_VENDOR
			– 使用MyBatis提供的VendorDatabaseIdProvider解析数据库
			厂商标识。也可以实现DatabaseIdProvider接口来自定义。
			• Property-name：数据库厂商标识
			• Property-value：为标识起一个别名，方便SQL语句使用
			databaseId属性引用
			
			<select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql">
				<!--  select id,last_name ,email,gender from tbl_employee where id = #{id}-->
				select * from tbl_employee where id = #{id}
			</select>
			
			<!--databaseIdProvider: 支持多数据库厂商 
	   			type="DB_VENDOR"
	   			 	typeAliasRegistry.registerAlias("DB_VENDOR", VendorDatabaseIdProvider.class);
	   			 	作用得到数据库厂商的标识(驱动自带的,connnect.getDataBaseProductName() )
	   			 	,mybaits就能根据数据库厂商表示执行不同的sql
	   			 	MySQL,Oracle,SQL Server,...
	   		-->
	   	
		   <databaseIdProvider type="DB_VENDOR">
		   	<!-- 为不同的数据库厂商起别名
		   			通过更换environments 的default属性就可以 更换不同的数据库方言
		   			然后对同一个sql映射进行 三种不同的sql  然后就能通过智能的使用databaseId 选择合适的sql映射
		   			
		   		<select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql" >
					select * from tbl_employee where id = #{id}
				</select>
				
				<select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee" databaseId="oracle" >
					select * from tbl_employee where id = #{id}
				</select>
				
		   	 -->
		   	
		   	<property name="MySQL" value="mysql"/>
		   	<property name="Oracle" value="oracle"/>
		   	<property name="SQL Server" value="sqlserver"/>
	   </databaseIdProvider>
	   
  mapper映射
  	• mapper逐个注册SQL映射文件
  		  <mappers>
   		 	<mapper resource="config/EmployeeMapper.xml"/>
  		</mappers>
  	• 或者使用批量注册：
		• 这种方式要求SQL映射文件名必须和接口名相同并且在同一目录下
		
		mappers>
  	<!-- 
  		mapper:注册一个sql映射
  			resource:引用类路径下的sql映射文件
  			url:引入网络路径或磁盘路径下的资源文件
  			
  			注册接口:
  			class:直接引用接口(注册接口),接口的全类名
  				
  				1.有sql映射文件,映射文件必须和接口同名,并且放在接口的同一目录下
  					 <mapper class="com.atguigu.mybatis.dao.EmployeeMapper"/>
  				
  				2.没有sql映射文件,利用注解写在接口上的,不推荐使用
  					public interface EmployeeAnnotation {
	
						@Select("select * from tbl_employee where id=#{id}")
						public Employee getEmpById(int id); 
					}
					
				推荐一些比较重要的来写sql映射文件,不重要的简单的的为了开发快速可以适用注解方式
				
				 <mapper class="com.atguigu.mybatis.dao.EmployeeMapper"/>
			 	<mapper class="com.atguigu.mybatis.dao.EmployeeAnnotation"/>
   			 	<mapper resource="com/atguigu/mybatis/dao/EmployeeMapper.xml"/>
				
			批量注册:
				<package name="com.atguigu.mybatis.dao" />
			
				
  	 -->
    	 <package name="com.atguigu.mybatis.dao" />
 	 </mappers>
	  
************************************************************************************************* 		
			
	小结:标签编写的有顺序的 和web.xml一样
				
		

***************************************************************************************************
四、MyBatis-映射文件

	映射文件指导着MyBatis如何进行数据库增删改查，有着非常重要的意义；
		•cache –命名空间的二级缓存配置
		•cache-ref – 其他命名空间缓存配置的引用。
		•resultMap – 自定义结果集映射
		•parameterMap – 已废弃！老式风格的参数映射
		•sql –抽取可重用语句块。
		•insert – 映射插入语句
		•update – 映射更新语句
		•delete – 映射删除语句
		•select – 映射查询语句
		
	insert、update、delete元素：
		id                命名空间中的睢一标i只符
		parameterType	    将要传入语句的参数的完全限定类名或别名。这个屋性是可选的，因为MyBatis可以通过TypeHandler推断出具体
						   传入语句的参数类型，默认值为unset
						   
		flushCache       将其设置为true ,任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：
						true (对应插入、更新删除语句）。
		
		timeout        这个设置是在拋出异常之前，驱动程序等持数据库返回请求结果的秒数。默认值为unset (依赖驱动）。   。
		
		statementType   STATEMENT , PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement,
						 PreparedStatement 或CallableStatement,默认值：PREPARED。  	  
		
		useGeneratedKeys  (仅对insert和update有用）这会令MyBatis使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的
                				 主键（比如：像MySQL和SQL Server这样的关系数据库管理系统的自动递增字段默认值：false
		
		keyProperty			(仅对insert和update有用）唯一标记一个雇性，MyBatis会通过getGeneratedKeys的返回值或者通过insert
                  			语句的selectKey子元素设置它的键值，默认：unset。
		                  
		keyColumn		(仅对insert和update有用）通过生成的键值设置表中的列名，这个设置仅在某库（像PostgreSQL )是必
                  		须的，当主键列不是表中的第一列的时候雲要设置。如果希望得到多个生成的列#也可以是逗号分隔的屋性名称列表。
		
		databaseld     如果配置了 databaseldProvider , MyBatis会加载所有的不带databaseld或匹配当前databaseld的语句；如果
              			芾或者不芾的语句都有#则不芾的会被忽略。   
                   
*************************************************************************************************************
	增删改查:
	
	/**
	 * 测试增删改
	 * 1.mybatis运行增删改定义一下类型的返回值(也可以不定义)
	 * 		Integer ,Long , Boolean 或者基本类  只需要在返回接口中 写上返回值就可以 无需在xml中设置 增删改也设置不了
	 * 		只有删除有
	 * 2.需要手动提交数据(因为opensession的时候是设置时手动提交的 也可以自动提交)
	
	
	1.
	<select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql" >
		<!--  select id,last_name ,email,gender from tbl_employee where id = #{id}-->
		select * from tbl_employee where id = #{id}
	</select>
	
	<select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee" databaseId="oracle" >
		<!--  select id,last_name ,email,gender from tbl_employee where id = #{id}-->
		select * from tbl_employee where id = #{id}
	</select>
	
	<!-- 
		parameterType：可以省略 指定全类名 或者别名
	 -->
	<insert id="addEmp" parameterType="com.atguigu.mybatis.bean.Employee" >
		insert into tbl_employee(last_name,gender,email) 
		values(#{lastName},#{gender},#{email})
	</insert>
	
	<update id="update">
		update tbl_employee set 
		last_name=#{lastName},
		gender=#{gender},
		email=#{email}
		where id = #{id}
	</update>
	
	<delete id="deleteEmpById">
		delete from tbl_employee where id=#{id}
	</delete>
	
	2.
	/**
	 * 测试增删改
	 * 1.mybatis运行增删改定义一下类型的返回值(也可以不定义)
	 * 		Integer ,Long , Boolean 或者基本类  只需要在返回接口中 写上返回值就可以 无需在xml中设置 增删改也设置不了
	 * 		只有删除有
	 * 2.需要手动提交数据
	 * @throws IOException
	 */
	public static void test4() throws IOException {
		String resource = "config/mybatis-config.xml";
		InputStream inputStream = Resources.getResourceAsStream(resource);
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
		
		//获取到的sqlSession不会自动提交数据
		SqlSession sqlSession = sqlSessionFactory.openSession();
		
		try {
			
			EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
			
//			Employee employee = new Employee(  null , "jerry" ,"jerry@atguigu.com","1");
//			mapper.addEmp(employee);
			Employee employee = new Employee(  2 , "Tom" ,"tom@atguigu.com","0");
			System.out.println( mapper.update(employee) );
			
			mapper.deleteEmpById(1);
			sqlSession.commit();
			
		} finally {
			
			sqlSession.close();
		}
		
	}
	
*************************************************************************************************************
	1.insert 获取自增主键的值（底层数据库要支持自增）
		
	<!-- 
		parameterType：可以省略 指定全类名 或者别名
		MySQL支持自增主键,自增主键值的获取,mybatis 利用statement.getGenreatedKeys()
		而我们要获取这个值只需要设置一个属性 useGeneratedKeys="true" 默认是false
		 useGeneratedKeys="true"：使用主键自增策略,
		 keyProperty:指定对应的主键属性,也就是mybatis获取到逐渐值以后将这个值封装给javabean的那个属性
	 -->
	<insert id="addEmp" parameterType="com.atguigu.mybatis.bean.Employee" 
	useGeneratedKeys="true" keyProperty="id">
		insert into tbl_employee(last_name,gender,email) 
		values(#{lastName},#{gender},#{email})
	</insert>
	
	2.对于不支持的自增的怎么办 ?
		Oracle使用序列 每次插入的是从序列中获取的值
		<!-- 
	获取非自增主键的值：
		Oracle不支持自增；Oracle使用序列来模拟自增；
		每次插入的数据的主键是从序列中拿到的值；如何获取到这个值；
	 -->
	<insert id="addEmp" databaseId="oracle">
		<!-- 
		keyProperty:查出的主键值封装给javaBean的哪个属性
		order="BEFORE":当前sql在插入sql之前运行
			   AFTER：当前sql在插入sql之后运行
		resultType:查出的数据的返回值类型
		
		BEFORE运行顺序：
			先运行selectKey查询id的sql；查出id值封装给javaBean的id属性
			在运行插入的sql；就可以取出id属性对应的值
		AFTER运行顺序：
			先运行插入的sql（从序列中取出新值作为id）；
			再运行selectKey查询id的sql；
		 -->
		<selectKey keyProperty="id" order="BEFORE" resultType="Integer" >
			<!-- 编写查询主键的sql语句 -->
			<!-- BEFORE-->
			select EMPLOYEES_SEQ.nextval from dual 
			<!-- AFTER：
			 select EMPLOYEES_SEQ.currval from dual -->
		</selectKey>
		
		<!-- 插入时的主键是从序列中拿到的 -->
		<!-- BEFORE:-->
		insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) 
		values(#{id},#{lastName},#{email<!-- ,jdbcType=NULL -->}) 
		<!-- AFTER：
		insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) 
		values(employees_seq.nextval,#{lastName},#{email}) -->
	</insert>	
	
*************************************************************************************************************
MyBatis 如何进行参数处理的
	
	单个参数：mybatis不会做特殊处理，
		#{参数名/任意名}：取出参数值。
		<select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql" >
			<!--  select id,last_name ,email,gender from tbl_employee where id = #{id}-->
			select * from tbl_employee where id = #{xxx}
		</select>	
			
		public Employee getEmpById(int id);
		
	多个参数：mybatis会做特殊处理。结论使用命名参数来做
		多个参数会被封装成 一个map，
			key：param1...paramN,或者参数的索引也可以
			value：传入的参数值
		#{}就是从map中获取指定的key的值；
		
		以下操作异常：
		
		org.apache.ibatis.binding.BindingException: 
		Parameter 'id' not found. 
		Available parameters are [1, 0, param1, param2]
		操作：
			方法：public Employee getEmpByIdAndLastName(Integer id,String lastName);
			取值：#{id},#{lastName}
			<select id="getEmpByIdAndLastName" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql" >
				<!--  select id,last_name ,email,gender from tbl_employee where id = #{id}-->
				select * from tbl_employee where id = #{id} and last_name=#{lastName}
			</select>
			
		以下可以正确操作
			<select id="getEmpByIdAndLastName" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql" >
				<!--  select id,last_name ,email,gender from tbl_employee where id = #{id}-->
			select * from tbl_employee where id = #{param1} and last_name=#{param2}
			</select>
		
		多参数推荐使用以下方式:
		
		【命名参数】：明确指定封装参数时map的key；@Param("id")
			多个参数会被封装成 一个map，
				key：使用@Param注解指定的值
				value：参数值
			#{指定的key}取出对应的参数值
			
			public Employee getEmpByIdAndLastName( @Param("id") int id ,@Param("lastName") String lastName);
		
			<select id="getEmpByIdAndLastName" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql" >
						<!--  select id,last_name ,email,gender from tbl_employee where id = #{id}-->
						select * from tbl_employee where id = #{id} and last_name=#{lastName}
			</select>
	
	TO：
	如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象
	Page{
		int index;
		int size;
	}
	
	POJO：
		如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo；
		#{属性名}：取出传入的pojo的属性值	

	Map：
		如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map
		#{key}：取出map中对应的值	
		
		public Employee getEmpByMap( Map<String,Object> map);
		
		<select id="getEmpByMap" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql" >
			<!--  select id,last_name ,email,gender from tbl_employee where id = #{id}-->
			select * from tbl_employee where id = #{id} and last_name=#{lastName}
		</select>
	
			
*************************************************************************************************************
                   
========================思考================================	
public Employee getEmp(@Param("id")Integer id,String lastName);
	取值：id==>#{id/param1}   lastName==>#{param2}

public Employee getEmp(Integer id,@Param("e")Employee emp);
	取值：id==>#{param1}    lastName===>#{param2.lastName/e.lastName}


##特别注意：如果是Collection（List、Set）类型或者是数组，
		 也会特殊处理。也是把传入的list或者数组封装在map中。
			key：Collection（collection）,如果是List还可以使用这个key(list)
				数组(array)
public Employee getEmpById(List<Integer> ids);
	取值：取出第一个id的值：   #{list[0]}
	
========================结合源码，mybatis怎么处理参数==========================
总结：参数多时会封装map，为了不混乱，我们可以使用@Param来指定封装时使用的key；
#{key}就可以取出map中的值；

(@Param("id")Integer id,@Param("lastName")String lastName);
ParamNameResolver解析参数封装map的；
//1、names：{0=id, 1=lastName}；构造器的时候就确定好了

	确定流程：
	1.获取每个标了param注解的参数的@Param的值：id，lastName；  赋值给name;
	2.每次解析一个参数给map中保存信息：（key：参数索引，value：name的值）
		name的值：
			标注了param注解：注解的值
			没有标注：
				1.全局配置：useActualParamName（jdk1.8）：name=参数名
				2.name=map.size()；相当于当前元素的索引
	{0=id, 1=lastName,2=2}
args【1，"Tom",'hello'】:

public Object getNamedParams(Object[] args) {
    final int paramCount = names.size();
    //1、参数为null直接返回
    if (args == null || paramCount == 0) {
      return null;
     
    //2、如果只有一个元素，并且没有Param注解；args[0]：单个参数直接返回
    } else if (!hasParamAnnotation && paramCount == 1) {
      return args[names.firstKey()];
      
    //3、多个元素或者有Param标注
    } else {
      final Map<String, Object> param = new ParamMap<Object>();
      int i = 0;
      
      //4、遍历names集合；{0=id, 1=lastName,2=2}
      for (Map.Entry<Integer, String> entry : names.entrySet()) {
      
      	//names集合的value作为key;  names集合的key又作为取值的参考args[0]:args【1，"Tom"】:
      	//eg:{id=args[0]:1,lastName=args[1]:Tom,2=args[2]}
        param.put(entry.getValue(), args[entry.getKey()]);
        
        
        // add generic param names (param1, param2, ...)param
        //额外的将每一个参数也保存到map中，使用新的key：param1...paramN
        //效果：有Param注解可以#{指定的key}，或者#{param1}
        final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1);
        // ensure not to overwrite parameter named with @Param
        if (!names.containsValue(genericParamName)) {
          param.put(genericParamName, args[entry.getKey()]);
        }
        i++;
      }
      return param;
    }
  }
}
=================================================================				
	
                   
*************************************************************************************************************
参数值的获取
	
	#{}：可以获取map中的值或者pojo对象属性的值;
	${}：可以获取map中的值或者pojo对象属性的值;

	select * from tbl_employee where id=${id} and last_name=#{lastName}
	Preparing: select * from tbl_employee where id=2 and last_name=?
	区别：
		#{}:是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入
		${}:取出的值直接拼装在sql语句中；会有安全问题；
		大多情况下，我们去参数的值都应该去使用#{}；
		
		原生jdbc不支持占位符的地方我们就可以使用${}进行取值
		比如分表、排序。。。；按照年份分表拆分
			select * from ${year}_salary where xxx;
			select * from tbl_employee order by ${f_name} ${order}

	#{}:更丰富的用法：
	规定参数的一些规则：
		javaType、 jdbcType、 mode（存储过程）、 numericScale、
		resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）；

	jdbcType通常需要在某种特定的条件下被设置：
		在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）；
		
		JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理;
			
		由于全局配置中：jdbcTypeForNull=OTHER;oracle不支持；两种办法
		1、#{email,jdbcType=OTHER};
		2、jdbcTypeForNull=NULL
			<setting name="jdbcTypeForNull" value="NULL"/>
			
*************************************************************************************************************
select元素
	• Select元素来定义查询操作。
	• Id：唯一标识符。
	– 用来引用这条语句，需要和接口的方法名一致
	• parameterType：参数类型。
	– 可以不传，MyBatis会根据TypeHandler自动推断
	• resultType：返回值类型。
	– 别名或者全类名，如果返回的是集合，定义集合中元素的类型。不能和resultMap同时使用

	1.select_返回List.avi
		<!-- 
 			public List<Employee> getEmpsByLastNameLike( String lastName );
 			resultType:如果返回的是一个集合要写集合中的元素的类型
 	 -->
 	 <select id="getEmpsByLastNameLike" resultType="com.atguigu.mybatis.bean.Employee">
 	 	select  * from tbl_employee where last_name like #{lastName}
 	 	
 	 2.select_记录封装map	
 	 		//返回一条记录map:key就是列名  值就是对应的值
			public Map<String, Object> getEmpByIdReturnMap(Integer id); 
 	 		 	<!-- 
 			应为mybatis已经为Map起了别名 map
		 	 -->
			<select id="getEmpByIdReturnMap" resultType="map">
		 	 	select  * from tbl_employee where id=#{xx}
		 	 </select>
		 	 输出
 			key:gender,value:1
			key:last_name,value:jerry
			key:id,value:1
			key:email,value:jerry@atguigu.com
			
		
			<!-- 	getEmpByLastNamesReturnMap  -->
	 	<select id="getEmpByLastNamesReturnMap" resultType="map" >
	 	 	select  * from tbl_employee where last_name like #{lastName}
	 	 </select>
	 	 
	 	 /**
			 * 多条记录返回map:Map<Interger,Employee> 键是这条记录的主键  值是封装后的javabean
			 * @MapKey("id"):告诉mybaits封装这个map的时候使用那个属性作为主键
			 * @param lastName
			 * @return
			 */
			@MapKey("id")
			public Map<Integer , Employee > getEmpByLastNamesReturnMap(  String lastName ) ;
			
			输出:
				{1={gender=1, last_name=jerry, id=1, email=jerry@atguigu.com}, 2={gender=1, last_name=jerry, id=2, email=jerry@atguigu.com}}
	
		
		3.resultMap 自定义结果集:
		
			自动映射
			• 1、全局setting设置
			– autoMappingBehavior默认是PARTIAL，开启自动映射
			的功能。唯一的要求是列名和javaBean属性名一致
			– 如果autoMappingBehavior设置为null则会取消自动映射
			– 数据库字段命名规范，POJO属性符合驼峰命名法，如
			A_COLUMNaColumn，我们可以开启自动驼峰命名规
			则映射功能，mapUnderscoreToCamelCase=true。
			
			如果数据库字段和pojo类属性名不对应 则可以使用resultMap实现自定义映射
		
		1.	
					<!-- 
				自定义某个javabean的规则
					type:自定义规则的java类型 也可以用别名 建议用全类名
					id:唯一id方便引用
			 -->
			<resultMap type="com.atguigu.mybatis.bean.Employee" id="MyEmp">
				<!--id 指定主键的封装规则
					id：定义主键底层会优化 
					column：指定那一列
					property:指定javabean属性
				-->
			<id column="id" property="id"/>
			<!-- 
				指定普通列封装规则
					
			 -->
			<result column="last_name" property="lastName" />
			<!-- 其他不指定的列会自动封装:我们只要写resultMap就把全部的映射规则都写上 -->
			<result column="email" property="email"/>
			<result column="gender" property="gender"/>
		</resultMap>
		
			<!-- public Employee getEmpById( Integer id); -->
			<!-- 
				resultMap：自定义结果集映射规则
					
			 -->
			
			<select id="getEmpById"  resultMap="MyEmp">
		 		select * from tbl_employee where id=#{id}
			</select>
			
				<!-- 
		场景一:
			查询Employee的同时查询员工对应的部门
			Employee ====Dempartment
			一个员工与之对应的部门信息
			getEmpAndDept
			 -->
		
		2.级联属性映射
			<!-- 
		 	联合查询：级联属性封装结果集
			  -->
			  public Employee getEmpAndDept( int id);
			  
			 <resultMap type="com.atguigu.mybatis.bean.Employee" id="MyDifEmp">
		 		<id column="id" property="id"/>
				<result column="last_name" property="lastName" />
				<result column="email" property="email"/>
				<result column="gender" property="gender" />
			 	<result column="did" property="dept.id" />
			 	<result column="dept_name" property="dept.departmentName" />
			 </resultMap>
			 
		 	<select id="getEmpAndDept"  resultMap="MyDifEmp">
		 		select e.id id , e.last_name last_name , e.email email, e.gender gender ,e.dept_id d_id,
		 		d.id did,d.dept_name dept_name
		 		from tbl_employee e, tbl_dept d 
		 		where e.id=d.id and e.id=#{id} 
			</select>		
			
		3.	级联属性映射 通过association标签映射
			 <!-- 
	 			association：定义单个对象的封装规则
 	  		-->
		  <resultMap type="com.atguigu.mybatis.bean.Employee" id="MyDif2Emp">
			  	<id column="id" property="id"/>
				<result column="last_name" property="lastName" />
				<result column="email" property="email"/>
				<result column="gender" property="gender" />
				<!-- association可以指定联合的javabean对象
					 property="dept" 指定那个属性是联合的对象
				 -->
				<association property="dept"  javaType="com.atguigu.mybatis.bean.Department">
					<id column="did" property="id"/>
					<result column="dept_name" property="departmentName"/>
				</association>
		  </resultMap>
		  
		  
		  3.及联属性 分布查询
		  	优点：可以使用延迟加载
		  
		  	 <!-- 
	  	使用association 进行分步查询
	  	1.先按照员工id查询员工信息
	  	2.根据查处员工信息的d_id值去部门表查出部门信息
	  	3.部门设置员工中
			   -->
		  	  <resultMap type="com.atguigu.mybatis.bean.Employee" id="MyEmpByStep">
		 	  		<id column="id" property="id"/>
					<result column="last_name" property="lastName" />
					<result column="email" property="email"/>
					<result column="gender" property="gender" />	
					<!-- association 定义关联对象的封装规则 
						select :表明当前属性是调用select 指定的方法查处结果
						column：指定将那一列的值传给这个方法
						
						流程:
							使用select指定的方法(传入column指定的这列) 查处对象,并封装给property指定的属性
					-->
		  	  		<association property="dept" select="com.atguigu.mybatis.dao.DepartmentMapper.getDeptById"
		  	  			column="dept_id"
		  	  		 >
		  	  			
		  	  		</association>
		  	 </resultMap>
		  	 
 			 <select id="getEmpByIdStep" resultMap="MyEmpByStep">
  	 				select * from tbl_employee where id=#{id}
  	 		</select>
		  	 
		  	 
					  	 <?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE mapper
			 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
			 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
			<mapper namespace="com.atguigu.mybatis.dao.DepartmentMapper">
				
				<select id="getDeptById" resultType="com.atguigu.mybatis.bean.Department">
						select id, dept_name departmentName from tbl_dept where id=#{id}
				</select>
				
			</mapper>
			
			public Employee getEmpByIdStep( int id);		
			
			<!-- 
  	 	分布查询可以使用延迟加载(懒加载)(按需加载):
  	 		Employee ===》dept
  	 		我们每次查询Employee对象的时候,都将部门信息一起查询出来了 
  	 		我们希望在使用的时候再去查询;
  	 		
  	 		分布查询基础上加上两个配置
  	 		<settings>
		<setting name="mapUnderscoreToCamelCase" value="true" />
		<setting name="logImpl" value="LOG4J" />
				<!-- 
					显示的指定我们需要更改的配置的值,即使它是默认的，防止更新带来的问题
				
				 -->
				<setting name="lazyLoadingEnabled" value="true"/>
				<setting name="aggressiveLazyLoading" value="false"/>
			</settings>
  	  -->
	
	
   select_resultMap_关联查询_collection定义关联集合封装规则：
   		_collection定义关联的集合类型的元素的封装规则:
   		
   	
				<select id="getDeptById" resultType="com.atguigu.mybatis.bean.Department">
					select id, dept_name departmentName from tbl_dept where id=#{id}
				</select>
			
			<!-- 
				场景2：
					查询部门的时候将部门对应的所有员工信息也查询出来
					
			 -->
			 <resultMap type="com.atguigu.mybatis.bean.Department" id="MyDept">
			 	<id column="did" property="id"/>
			 	<result column="dept_name" property="departmentName"/>
			 	<!-- 
			 		collection定义关联的集合类型封装的规则
			 		ofType:指定集合中元素的属性
			 	 -->
			 	<collection property="emps" ofType="com.atguigu.mybatis.bean.Employee" >
			 		<id column="eid" property="id"/>
			 		<result column="last_name" property="lastName"/>
			 		<result column="email" property="email"/>
			 		<result column="gender" property="gender"/>
			 		<association property="dept" javaType="com.atguigu.mybatis.bean.Department">
			 			<id column="did" property="id"/>
			 			<result column="dept_name" property="departmentName"/>
			 		</association>
			 	</collection>
			 </resultMap>
			 
			<select id="getDeptByIdPlus" resultMap="MyDept">
			    select d.id did , d.dept_name dept_name ,
				e.id eid , e.last_name last_name, e.email email, e.gender gender
				from tbl_dept d left join tbl_employee  e 
				on d.id = e.dept_id 
				where d.id=#{id}	
			</select>
			
		_collection 分布查询：
					public Employee getEmpByIdStep( int id);
					
					  <resultMap type="com.atguigu.mybatis.bean.Department" id="MyDept2">
			 	<id column="did" property="id"/>
			 	<result column="dept_name" property="departmentName"/>
			 	<!-- 
			 		collection定义关联的集合类型封装的规则
			 		ofType:指定集合中元素的属性
			 	 -->
			 	<collection property="emps" select="com.atguigu.mybatis.dao.EmployeeMapperPlus.getEmpAndDept" 
			 	column="id" >
			 	<!-- 
			扩展 :多列的值传递过去,将多列的值封装成map传递:
			fetchType="lazy"：表示使用延迟加载  也可以禁止掉 取值:
						-lazy：延迟加载
						-eager:立即加载（即使全局开启了延迟加载 这个也可以立即加载）
								eager：急于
			column="{key=column1,key2=column2 }"
			:column="{deptid=id}"
	 	-->	
			 	</collection>
			 </resultMap>
	 
	 
			<select id="getDeptByIdPlus" resultMap="MyDept2">
			    select d.id did , d.dept_name dept_name ,
				e.id eid , e.last_name last_name, e.email email, e.gender gender
				from tbl_dept d left join tbl_employee  e 
				on d.id = e.dept_id 
				where d.id=#{id}	
			</select>
	
	discriminator:鉴别器  了解内容用的不多
			
	<!-- 
		
		 <discriminator javaType=""></discriminator>
		 鉴别器:discriminator
		 mybaits 可以使用discriminator判断某列的值,然后根据某列的值改变封装行为
		 封装Employee:
		 	如果查出的是女生：就把部门信息查询处理啊 负责不查询
		 	如果是男生：就把last_name把这一列的值赋值给email
		 -->
		<resultMap type="com.atguigu.mybatis.bean.Employee" id="MyEmpDis">
			<id column="id" property="id"/>
			<result column="last_name" property="lastName" />
			<result column="email" property="email"/>
			<result column="gender" property="gender" />
 	  		<!-- 
				column:指定要判定的列名
				javaType:列值对应的javaType
			 -->
			<discriminator javaType="string" column="gender">
				<!-- 女生 resultType：指定封装的结果
					resultMap不能缺少 二选一 
				 -->
				<case value="0" resultType="com.atguigu.mybatis.bean.Employee">
							
					<association property="dept" select="com.atguigu.mybatis.dao.DepartmentMapper.getDeptById"
	  					column="dept_id">
	  				</association>
				</case>
				
				<!-- 男生 -->
				<case value="1" resultType="com.atguigu.mybatis.bean.Employee">
					<id column="id" property="id"/>
					<result column="last_name" property="lastName" />
					<result column="last_name" property="email"/>
					<result column="gender" property="gender" />
				</case>
			</discriminator>
		</resultMap> 		
			
*************************************************************************************************************
MyBatis 动态sql:
		
	• 动态 SQL是MyBatis强大特性之一。极大的简化我们拼装
	SQL的操作。
	• 动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处
	理器相似。
	• MyBatis 采用功能强大的基于 OGNL 的表达式来简化操作。
	– if
	– choose (when, otherwise)
	– trim (where, set)
	– foreach
	
	
	OGNL（ Object Graph Navigation Language ）对象图导航语言，这是一种强大的
	
		表达式语言，通过它可以非常方便的来操作对象属性。 类似于我们的EL，SpEL等
		访问对象属性： person.name
		调用方法： person.getName()
		调用静态属性/方法： @java.lang.Math@PI
		@java.util.UUID@randomUUID()
		调用构造方法： new com.atguigu.bean.Person(‘admin’).name
		运算符： +,-*,/,%
		逻辑运算符： in,not in,>,>=,<,<=,==,!=
		注意：xml中特殊符号如”,>,<等这些都需要使用转义字符
		类型 伪属性 伪属性对应的 Java 方法
		List、Set、Map size、isEmpty List/Set/Map.size(),List/Set/Map.isEmpty()
		List、Set iterator List.iterator()、Set.iterator()
		Map keys、values Map.keySet()、Map.values()
		Iterator next、hasNext Iterator.next()、Iterator.hasNext()
		
		
	<!-- 
		– if
		– choose (when, otherwise)
		– trim (where, set)
		– foreach
		
	 -->
	 
	 <!-- 查询员工:
	 	携带了那个字段，查询条件就带上那个字段值
	  -->

	<select id="getEmpsByConditionIf" resultType="com.atguigu.mybatis.bean.Employee">
			select * from tbl_employee 
			
			
			<!--
			<if>
			 test：判断表达式(ongl) c:if test(el)一样 
				OGNL 使用参照ppt
				从参数中取值进行判断
				
				遇见特殊符号应该 使用转义字符
					and 等价于   &quot;&quot;
					&&:and 
					":&quot;&quot;
				
				<where>	
				查询的时候如果某些条件没带可能sql拼装会有问题
					两种解决方案: 
						where 1=1 
						mybaits 使用<where> 标签 来将所有的条件包裹，多余的and或者or会被去掉
							有时候也不好使 and 或者or放在后面的话就不好用 这个<where> 只会去掉第一个多出来的and 或者or
							
				<trim>	
			  -->
			 <where>
			<if test="id != null ">
				id=#{id} 
			</if>
			
			<if test=" lastName != null and lastName != '' " >
				 and last_name like #{lastName}
			</if>
			
			<if test=" email != null and email.trim() != ''" >
				 and email = #{email}
			</if>
				
				<!-- ognl会自动进行字符串与数字的转换判断 -->
			<if test=" gender==0 and  gender == 1 " >
				and gender=#{gender}
			</if>
		</where> 
	</select>
	
	<select id="getEmpsByConditionTrim" resultType="com.atguigu.mybatis.bean.Employee">
	
		select * from tbl_employee  
		<!-- 
			后面多出的and或者or where标签不能解决 
			trim: 自定义字符串截取规则
				prefix	前缀
						 trim标签体中是整个字符串拼串后的结果 ，给拼串后的整个字符串加一个前缀，可写
				prefixOverrides:前缀覆盖
						去掉整个字符串前面多余的字符
				suffix:后缀
					 trim标签体中是整个字符串拼串后的结果 ，给拼串后的整个字符串加一个后缀，可写	
				suffixOverrides
					去掉整个字符串后面多余字符
		 -->
		<trim prefix="where" prefixOverrides="" suffix="" suffixOverrides="and">
			<if test="id != null ">
					id=#{id}  and 
				</if>
				
				<if test=" lastName != null and lastName != '' " >
					  last_name like #{lastName} and
				</if>
				
				<if test=" email != null and email.trim() != ''" >
					  email = #{email} and
				</if>
					
					<!-- ognl会自动进行字符串与数字的转换判断 -->
				<if test=" gender==0 and  gender == 1 " >
					 gender=#{gender} and
				</if>
			</trim>
	</select>
	
	<!-- 
		choose(when , othrewise):
			分支选择 :相当于 swith - case 
			如果带了id 查询 
			如果带了 lastName就用lasName查询 只会进入其中一个
			
	 -->
	 
	 <select id="getEmpsByConditionChoose" resultType="com.atguigu.mybatis.bean.Employee">
	 	select * from tbl_employee 
	 	<trim prefix="where">
	 		<choose >
	 			<when test="id != null ">
	 				id = #{id}
	 			</when>	
	 			<when test="lastName != null and lastName != ''">
	 				last_name like #{lastName}
	 			</when>
	 			<otherwise>
	 				1 = 1
	 			</otherwise>
	 		</choose>
	 	</trim>
	 </select>
	 
	 
	<!-- 
		set:
			封装修改条件的	
			使用set可以消除多余的逗号
			可以和where 一样用 trim替代
	 -->
	<update id="updateEmp" >
		update tbl_employee
		<set>
			<if test="lastName!=null ">
				last_name = #{lastName},
			</if> 
			
			<if test="email != null ">
				email = #{email},
			</if>
			
			<if test=" gender != null ">
				gender = #{gender}
			</if>
		</set>	
		where id = #{id}
	</update>
	
	
	 <select id="getEmpsByConditionForeach" resultType="com.atguigu.mybatis.bean.Employee"> 
	 	
	 			select * from tbl_employee  where id in
	 		
	 	<!-- -
		<foreach>
			collecion:指定要变量的集合
				:类型的参数会特殊处理封装在map中,map的key就叫做list  使用@Param注解重新定义键值
			item:就是将当前变量出来的元素赋值给指定的变量 
				#{变量名}就能取出变量的值 也就是当前遍历出的元素
			separator:
				每个元素的之间的分隔符
			open:变量出所有的结果 拼接一个开始的字符
			close:变量出所有的结果 拼接一个结束的字符
			index:索引:变量list的时候是一个索引  
					变量map的时候就是map的key  item 是map的值
		 -->	
		
		 	<foreach collection="ids" item="id" separator="," open="(" close=")"
		 	>
		 		#{id}
		 	</foreach>
	 </select>
	 
	 <!-- 
	 	批量保存:
	 		两种方式:
	 		mysql下的批量保存可以foreach变量 values  mysql支持values(),(),()
	 		Oracle 不支持这中写法
	 		
	 		
	 			  <insert id="addEmps">
	  	
	  		insert into tbl_employee( last_name , email , gender,dept_id )
	  		values	
	  		
	  		<foreach collection="emps"  separator="," item="emp">
	  			(#{emp.lastName} , #{emp.email } , #{emp.gender} , #{emp.dept.id}) 
	  		</foreach>
	  	
	  </insert>
	  -->
		<!-- 这种方式需要数据库连接属性
			jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMutiQueries=true
			allowMutiQueries 属性的支持
			
			这种分号分割多个sql可以用于其他的批量操作
		 -->
		<insert id="addEmps"> 
			<foreach collection="emps" separator=";" item="emp" >
			insert into tbl_employee( last_name , email , gender,dept_id )
			values(#{emp.lastName} , #{emp.email } , #{emp.gender} , #{emp.dept.id})
			</foreach>
		</insert>
		
		
		<!-- Oracle数据库批量保存： 
	 	Oracle不支持values(),(),()
	 	Oracle支持的批量方式
	 	1、多个insert放在begin - end里面
	 		begin
			    insert into employees(employee_id,last_name,email) 
			    values(employees_seq.nextval,'test_001','test_001@atguigu.com');
			    insert into employees(employee_id,last_name,email) 
			    values(employees_seq.nextval,'test_002','test_002@atguigu.com');
			end;
		2、利用中间表：
			insert into employees(employee_id,last_name,email)
		       select employees_seq.nextval,lastName,email from(
		              select 'test_a_01' lastName,'test_a_e01' email from dual
		              union
		              select 'test_a_02' lastName,'test_a_e02' email from dual
		              union
		              select 'test_a_03' lastName,'test_a_e03' email from dual
		       )	
	 -->
	 <insert id="addEmps" databaseId="oracle">
	 	<!-- oracle第一种批量方式 -->
	 	<!-- <foreach collection="emps" item="emp" open="begin" close="end;">
	 		insert into employees(employee_id,last_name,email) 
			    values(employees_seq.nextval,#{emp.lastName},#{emp.email});
	 	</foreach> -->
	 	
	 	<!-- oracle第二种批量方式  -->
	 	insert into employees(
	 		<!-- 引用外部定义的sql -->
	 		<include refid="insertColumn">
	 			<property name="testColomn" value="abc"/>
	 		</include>
	 	)
	 			<foreach collection="emps" item="emp" separator="union"
	 				open="select employees_seq.nextval,lastName,email from("
	 				close=")">
	 				select #{emp.lastName} lastName,#{emp.email} email from dual
	 			</foreach>
	 </insert>
	 
	 
	  <!-- 
	  	抽取可重用的sql片段。方便后面引用 
	  	1、sql抽取：经常将要查询的列名，或者插入用的列名抽取出来方便引用
	  	2、include来引用已经抽取的sql：
	  	3、include还可以自定义一些property，sql标签内部就能使用自定义的属性
	  			include-property：取值的正确方式${prop},
	  			#{不能使用这种方式}
	  			
	  			
	  -->
	  <sql id="insertColumn">
	  		<if test="_databaseId=='oracle'">
	  			employee_id,last_name,email
	  		</if>
	  		<if test="_databaseId=='mysql'">
	  			last_name,email,gender,d_id
	  		</if>
	  </sql>
	  
	  <!-- 两个内置参数:
	  		不只是方法传递过来的参数可以被用来判断或者取值...
	  		mybatis 默认两个内置的参数:
	  		_parameter: 
	  			单个参数:__parameter就是这个参数
	  			多个参数:参数会被封装成一个map,_parameter就代表这个map
	  		_databaseId:
	  			:如果配置了DatabaseIdProvider标签,
	  			__databaseId这个就代表当前数据库的别名
	  	 -->
	   <!--public List<Employee> getEmpsTestInnerParameter(Employee employee);  -->
	  <select id="getEmpsTestInnerParameter" resultType="com.atguigu.mybatis.bean.Employee">
	  		<!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值
	  			这样就可以实现模糊查询 不用在java文件传入了
	  			
	  			不能在sql中这样 在'%#{lastname}%'
	  			这样子就无法正确解析
	  			可以这样子%${lastname}%' 但是这样不安全 有sql注入的风险
	  			推荐传的时候就传%%  
	  		 -->
	  		<bind name="_lastName" value="'%'+lastName+'%'"/>
	  		<if test="_databaseId=='mysql'">
	  			select * from tbl_employee
	  			<if test="_parameter!=null">
	  				where last_name like #{lastName}
	  			</if>
	  		</if>
	  		<if test="_databaseId=='oracle'">
	  			select * from employees
	  			<if test="_parameter!=null">
	  				where last_name like #{_parameter.lastName}
	  			</if>
	  		</if>
	  </select>


*************************************************************************************************************
六、MyBatis-缓存机制

	• MyBatis 包含一个非常强大的查询缓存特性,它可以非
	常方便地配置和定制。缓存可以极大的提升查询效率。
	
	• MyBatis系统中默认定义了两级缓存。
	
	• 一级缓存和二级缓存。
		– 1、默认情况下，只有一级缓存（SqlSession级别的缓存，
		也称为本地缓存）开启。
		– 2、二级缓存需要手动开启和配置，他是基于namespace级
		别的缓存。
		– 3、为了提高扩展性。MyBatis定义了缓存接口Cache。我们
		可以通过实现Cache接口来自定义二级缓存
	
	
	/*
	 * 两级缓存:
	 * 		一级缓存:(本地缓存) sqlSession级别的缓存
	 * 			与数据库同一次会话期间 会放在本地缓存中 
	 * 			以后如果要获取相同的数据，直接从缓存中拿,没必要再去查询数据库;
	 * 			
	 * 			一级缓存的失效情况(没有使用到当前一级缓存的情况，效果是还需要再向数据库发出查询)
	 * 				1.sqlSession不同
	 * 				2.同一个SqlSession但是查询条件不同,当前缓存中还没有这个数据
	 * 				3.同一个SqlSession两次查询期间执行了任何一次增删改操作(这次增删改可能会影响当前数据)
	 * 				4.同一个SqlSession两次查询期间手动清空了缓存
	 * 					 sqlSession.clearCache();
	 * 	 	二级缓存:(全局缓存) namespace级别的缓存：一个namespace 对应一个二级缓存
	 * 			工作机制:
	 * 				1.一个会话 查询一条数据，这个数据就会放在当前;
	 * 				2.如果会话关闭,一级缓存中的数据会被保存到二级缓存中,新的会话查询就可以参照二级缓存中的内容
	 * 				3.sqlSession ==== EmployeeMapper ===>Employee	
	 * 								   DepartmentMapper == >Department
	 * 					这两个是不同的namespace 
	 * 					不同的namespace 查出的数据会放在自己对应的缓存中(map)
	 * 
	 * 					效果:
	 * 						查出的数据会被默认放在一级缓存中
	 * 						只有会话提交或者关闭后一级缓存中的数据才会转移到二级缓存
	 * 				
	 * 			使用:
	 * 			  1)开启全局二级缓存配置:
	 * 					<setting name="cacheEnabled" value="true"/>
	 * 			  2)去mapper.xml中配置使用二级缓存
	 * 					<cache></cache>	
	 * 	
		 * 				eviction:缓存的回收策略
								• LRU – 最近最少使用的：移除最长时间不被使用的对象   默认值。
								• FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
								• SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
								• WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
								• 默认的是 LRU
					   flushInterval：刷新间隔，单位毫秒
							• 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新
			
					   size：引用数目，正整数
							• 代表缓存最多可以存储多少个对象，太大容易导致内存溢出
			
					   readOnly：只读，true/false
							• true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象
								不能被修改。这提供了很重要的性能优势。
							 	mybatis认为所有从缓存中获取数据的操作都是只读操作的不会修改数据
							 	mybatis为了加快获取速度直接就会将数据在缓存中的引用交给用户
							 	
							• false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，
							   	  但是安全，因此默认是 false。
							     mybatis认为所有从缓存中获取数据的操作可能会修改数据
							     mybatis会利用序列化和反序列化技术克隆一份新的数据给你
							     
					   type:指定自定义缓存的全类名(不需要指定); 要自定义可以实现Cache接口
				   
				  3.因为用了反序列化技术我们pojo需要实现序列化接口
				
			和缓存有关的设置和属性:
				  	1. <setting name="cacheEnabled" value="true"/>
				  		设置为false 	 关闭缓存(二级缓存关闭 ) 一级缓存一直可用
				    2.每个select标签都有userCache="true"标签
				    	false:不使用缓存 (一级缓存依然使用 二级缓存不使用)	
	 * 				3.每个增删改标签:都有个flushCache="true"(默认是true): 
	 * 					意思是增删改执行后就会清除缓存
	 * 					一级缓存就清除了 二级缓存也会清除
	 * 			   		查询标签:的flushCache默认是false
	 * 				4.sqlSession.clearCache();只是清除当前的一级缓存 
	 * 
	 * 				5.localCacheScope:mybatis 3.3后支持  一般也没人配置
	 * 					当前会话的所有数据保存在会话缓存中
	 * 					
	 * 					默认值是session sqlsession级别的
	 * 					取值statement：就是没有缓存 禁用掉一级缓存
	 * 
	 * 	一级缓存和二级缓存的工作原理：
	 * 		一个sqlsession代表和数据库的一次会话
	 * 		
	 * 	
	 * 第三方缓存整合：
	 * 
	 * 	EhCache 是一个纯Java的进程内缓存框架，具有快速、精
		干等特点，是Hibernate中默认的CacheProvider。
		• MyBatis定义了Cache接口方便我们进行自定义扩展。
			• 步骤：
			– 1、导入ehcache包，以及整合包，日志包
				ehcache-core-2.6.8.jar、mybatis-ehcache-1.0.3.jar
				slf4j-api-1.6.1.jar、slf4j-log4j12-1.6.2.jar
			– 2、编写ehcache.xml配置文件
			– 3、配置cache标签
			– <cache type="org.mybatis.caches.ehcache.EhcacheCache"></cache>	
			
			参照缓存：若想在命名空间中共享相同的缓存配置和实例。
			可以使用 cache-ref 元素来引用另外一个缓存。
			namespace 指定和那个命名空间下的缓存一样
			<cache-ref namespace="xxx"
	 * 
	 * 				
	 */

*************************************************************************************************************
	
MyBatis-Spring整合

	1、查看不同MyBatis版本整合Spring时使用的适配包；
		http://www.mybatis.org/spring/
	2、下载整合适配包
		https://github.com/mybatis/spring/releases
	• 3、官方整合示例，jpetstore
		https://github.com/mybatis/jpetstore-6

	整合关键配置
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
	
		<!-- 指定mybatis全局配置文件位置 -->
		<property name="configLocation" value="classpath:mybatis/mybatis-config.xml"></property>
	
		<!--指定数据源 -->
		<property name="dataSource" ref="dataSource"></property>
	
		<!--mapperLocations：所有sql映射文件所在的位置 -->
		<property name="mapperLocations" value="classpath:mybatis/mapper/*.xml"></property>
		
		<!--typeAliasesPackage：批量别名处理-->
		<property name="typeAliasesPackage" value="com.atguigu.bean"></property>
		
	</bean>
	
	<!--自动的扫描所有的mapper的实现并加入到ioc容器中 -->
	<bean id="configure" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		
		<!– basePackage:指定包下所有的mapper接口实现自动扫描并加入到ioc容器中 -->
		<property name="basePackage" value="com.atguigu.dao"></property>
	</bean>
	
	整合的目的:
	
		通过spring管理各个组件 用spring控制事务 
		
		ssm整合:
			spring ioc容器的包:
				beans context exproession core 
			
			spring做jdbc模块需要的jar包
				jdbc orm tx 
			
			spring web 模块
				web webmvc
				
			spring aop方面的包:
				spring-aop 
				spring-aspects
				springsource.net.sf.cglib
				springsource.org.aopalliance
				springsource.org.aspectj.weaver
			jstl:
				taglibs-standard-impl
				taglibs-standard-spec 
			日志:
				commons-log
	
	spring配置文件
	
					
	
	<context:property-placeholder location="classpath:config/dbconfig.properties"/>
		
	<context:component-scan base-package="com.atguigu.mybatis">
		<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
	
	
	<!-- 配置数据源 -->
	<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
		<property name="username" value="${jdbc.user}"></property>
		<property name="password" value="${jdbc.password}"></property>
		<property name="url" value="${jdbc.url}"></property>
		<property name="driverClassName" value="${jdbc.driver}"></property>
		<property name="initialSize" value="5"></property>
		<property name="maxActive" value="25"></property>
	</bean>
	
	<!-- 整合mybatis
		目的:
			1.spring来管理所有组件,包括mapper的实现类
				service ===》Dao  @AutoWire  自动注入Mapper；避免了
			2.spring 管理事务
			
			SqlSessionFactoryBean:实现了Spring的FactoryBean接口
			Spring会调用其中的getObject方法 改方法返回SqlSessionFactory
			让Spring一启动就创建这个
			
	 -->	
	<bean id="sessionFactoryBean"  class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource"></property>
		<property name="configLocation" value="classpath:config/mybatis-config.xml"></property> 
		<!-- 指定mapper文件的配置(不用在同一路径下 同名) 或者通过 MapperScannerConfigure进行扫描-->
		<!--<property name="mapperLocations" value="classpath:/xx/*.xml"></property>  -->
	</bean>
	
	<!-- 配置扫描包，加载mapper代理对象 -->
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="com.atguigu.mybatis.dao"></property>
	</bean>	
	
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	<!-- 扫描所有mapper接口的实现 让这些mapper能够自动注入  如果配置了MapperScannerConfigure这个配置就不需要了-->
	<!--  <mybatis-spring:scan base-package="com.atguigu.mybatis.dao"/>-->
	
	<tx:advice transaction-manager="transactionManager" id="txAdvice">
		<tx:attributes>
			<tx:method name="get*" propagation="SUPPORTS" read-only="true"/>
			<tx:method name="select*" propagation="SUPPORTS" read-only="true"/>
			<tx:method name="delete*" propagation="REQUIRED"/>
			<tx:method name="save*" propagation="REQUIRED"/>
			<tx:method name="update*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
	
	<aop:config>
		<aop:pointcut expression="execution( * com.atguigu.mybatis.services.*.*(..) )" id="pointCut"/>
		<aop:advisor advice-ref="txAdvice" pointcut-ref="pointCut"/>
	</aop:config>
				
	
	springmvc 配置文件
	
	<context:component-scan base-package="com.atguigu.mybatis" >
		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
	
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/"></property>
		<property name="suffix" value=".jsp"></property>
	</bean>
	<mvc:annotation-driven>
	</mvc:annotation-driven>
	<mvc:default-servlet-handler/>
			
			
		<dependencies>
		
		<dependency>
		    <groupId>org.mybatis</groupId>
		    <artifactId>mybatis-spring</artifactId>
		    <version>1.3.2</version>
		</dependency>
		
	<dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-web</artifactId>
	    <version>4.3.14.RELEASE</version>
	</dependency>
	
	<dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-webmvc</artifactId>
	    <version>4.3.14.RELEASE</version>
	</dependency>
		
	<dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-jdbc</artifactId>
	    <version>4.3.14.RELEASE</version>
	</dependency>
			
	<dependency>
	    <groupId>org.springframework.batch</groupId>
	    <artifactId>spring-batch-infrastructure</artifactId>
	    <version>3.0.9.RELEASE</version>
	</dependency>
	
	<dependency>
	    <groupId>log4j</groupId>
	    <artifactId>log4j</artifactId>
	    <version>1.2.17</version>
	</dependency>
	
	<dependency>
	    <groupId>org.mybatis</groupId>
	    <artifactId>mybatis</artifactId>
	    <version>3.4.6</version>
	</dependency>
	
	<dependency>
	    <groupId>mysql</groupId>
	    <artifactId>mysql-connector-java</artifactId>
	    <version>5.1.38</version>
	</dependency>
	
		<!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects -->
	<dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-aspects</artifactId>
	    <version>4.3.14.RELEASE</version>
	</dependency>
	
	<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
		<dependency>
		    <groupId>com.alibaba</groupId>
		    <artifactId>druid</artifactId>
		    <version>1.1.10</version>
		</dependency>
			
	<!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api -->
<dependency>
    <groupId>javax.servlet.jsp</groupId>
    <artifactId>javax.servlet.jsp-api</artifactId>
    <version>2.2.1</version>
    <scope>provided</scope>
</dependency>
	
	
	<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
</dependency>
	
	</dependencies>
  
   <build>
  	<resources>  
        <resource>  
            <directory>src/main/resources</directory>  
            <includes>  
                <include>**/*.properties</include>  
                <include>**/*.xml</include>  
                <include>**/*.tld</include>  
            </includes>  
            <filtering>false</filtering>  
        </resource>  
        <resource>  
            <directory>src/main/java</directory>  
            <includes>  
                <include>**/*.properties</include>  
                <include>**/*.xml</include>  
                <include>**/*.tld</include>  
            </includes>  
            <filtering>false</filtering>  
        </resource>  
    </resources>
  </build>		

*************************************************************************************************************
八、MyBatis-逆向工程
	• MyBatis Generator：
	• 简称MBG，是一个专门为MyBatis框架使用者定
		制的代码生成器，可以快速的根据表生成对应的
		映射文件，接口，以及bean类。支持基本的增删
		改查，以及QBC风格的条件查询。但是表连接、
		存储过程等这些复杂sql的定义需要我们手工编写
	• 官方文档地址
	http://www.mybatis.org/generator/
	• 官方工程地址
	https://github.com/mybatis/generator/releases
	
		mybatis-generator-core-1.3.2-bundle.zip:
			mybatis-generator-core-1.3.2.jar   需要导入的
			mybatis-generator-core-1.3.2-javadoc.jar  文档
			mybatis-generator-core-1.3.2-sources.jar  源码包
	MBG使用
		使用步骤：
		– 1）编写MBG的配置文件（重要几处配置）
		1）jdbcConnection配置数据库连接信息
		2）javaModelGenerator配置javaBean的生成策略
		3）sqlMapGenerator 配置sql映射文件生成策略
		4）javaClientGenerator配置Mapper接口的生成策略
		5）table 配置要逆向解析的数据表
		tableName：表名
		domainObjectName：对应的javaBean名
		– 2）运行代码生成器生成代码
		• 注意：
		Context标签
		targetRuntime=“MyBatis3“可以生成带条件的增删改查
		targetRuntime=“MyBatis3Simple“可以生成基本的增删改查
		如果再次生成，建议将之前生成的数据删除，避免xml向后追加内容出现的问
		题。
		
		配置文件:
			
			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
			<generatorConfiguration>
			<!-- 
				targetRuntime="MyBatis3Simple" 生成的简单版的CRUD
				targetRuntime="MyBatis3" 生成的豪华版的
				
			 -->
				 
			
			 
			  <context id="context1" targetRuntime="MyBatis3">
			  	
			 	<commentGenerator>
						<!-- 是否去除自动生成的注释 true：是 ： false:否 -->
						<property name="suppressAllComments" value="true" />
				</commentGenerator>
			  	
			  	<!-- 指定如何链接目标数据库 -->
			    <jdbcConnection connectionURL="jdbc:mysql://localhost:3306/mybatis" 
			    driverClass="com.mysql.jdbc.Driver" password="123456" userId="root" />
			    
			    <!--  是否强制转换forceBigDecimals-->
			    <javaTypeResolver>
			    	<property name="forceBigDecimals" value="false"/>
			    </javaTypeResolver>
			    
			    <!-- 指定javaBean的生成策略
			    	targetPackage:目标的包名
			    	targetProject:目标工程	 ./mybatisMbg-7/src
			     -->
			    <javaModelGenerator targetPackage="com.atguigu.mybatis.bean" targetProject=".\src" />
			    
			    <!-- 
			    	sqlMapGenerator:sql映射的生成策略
			    		targetPackage:目标的包名
			    		targetProject:目标工程	
			     -->
			    <sqlMapGenerator targetPackage="com.atguigu.mybatis.dao" targetProject=".\src" />
				
				<!-- 
					javaClientGenerator:指定Mapper接口的生成策略
						
				 -->
			    <javaClientGenerator targetPackage="com.atguigu.mybatis.dao" targetProject=".\src" type="XMLMAPPER" />
				
				<!-- 
					用来指定要逆向分析哪些数据表，根据表要创建javabean
						tableName:指定表明
						domainObjectName:指定要生成的类名
				 -->
			    <table tableName="tbl_dept" domainObjectName="DepartMent" >
			    </table>
			    <table  tableName="tbl_employee" domainObjectName="Employee">
			    </table>
			  </context>
			  
			   <table tableName="mmall_category" domainObjectName="Category" 
			   enableCountByExample="false" enableUpdateByExample="false" 
			   enableDeleteByExample="false" enableSelectByExample="false"
			    selectByExampleQueryId="false"></table> 
			    
			</generatorConfiguration>
			
			
		自动生成代码：
			
			public static void testMbg() throws Exception {
					
				   List<String> warnings = new ArrayList<String>();
				   boolean overwrite = true;
				   File configFile = new File("generatorConfig.xml");
				   
				   System.out.println(configFile.exists());
				   ConfigurationParser cp = new ConfigurationParser(warnings);
				   Configuration config = cp.parseConfiguration(configFile);
				   DefaultShellCallback callback = new DefaultShellCallback(overwrite);
				   MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
				   myBatisGenerator.generate(null);
		
	   
			}
			
		查询：
			public static void testMyBatis3() {
		
		try {
			InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
			SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
			
			SqlSession sqlSession = sqlSessionFactory.openSession();
			
			EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
			
			//xxxExample就是封装了查询条件
			
			List<Employee> emps = mapper.selectByExample(null);
			for (int i = 0; i < emps.size(); i++) {
				System.out.println( emps.get(i).getId());
			}
			
			//查询员工姓名中有e字母的和性别是1的
			//封装员工查询条件的
			EmployeeExample employeeExample = new EmployeeExample();
			//创建一个Criteria 这个Criteria就是封装了查询条件的
			EmployeeExample.Criteria criteria = employeeExample.createCriteria();
			
			criteria.andLastNameLike("%e%");
			criteria.andGenderEqualTo("0");
			
			 emps = mapper.selectByExample(employeeExample);
			 
			 for (int i = 0; i < emps.size(); i++) {
					System.out.println( emps.get(i).getId());
			  }
			 
			 //怎么创建or操作
			 
			 EmployeeExample.Criteria criteria2 =    employeeExample.createCriteria();
			 
			 criteria2.andEmailLike("%@%");
			 employeeExample.or(criteria2);
			 
			 emps = mapper.selectByExample(employeeExample);
			 
			 for (int i = 0; i < emps.size(); i++) {
					System.out.println( emps.get(i).getId());
			  }
			 
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
			
*************************************************************************************************************
九 mybatis运行原理:

	理解四大对象的作用:
		Executor StatementHandler ParamertHander ResultSetHandler
		
		/**
	 * 1.获取sqlSessionFactory
	 * 		解析文件的每一个信息保存在Configuration中返回包含Configuration的DefaultSqlSessionFactory
	 * 		注意:MappedStatement:代表一个增删改查的标签的详细信息
	 * 2.获取sqlSession
	 * 		包含了Executor(四大对象之一) 和 Configuration
	 * 3.获取接口的实现类对象
	 * 4.执行增删改查
	 * 
	 * Executor 
	 * ParameterHandler 
	 * ResultSetHandler
	 * StatementHandler
	 * @throws IOException
	 * 		
	 * SqlSessionFactory 的创建流程:
	 * 		把所有的配置信息保存在Configuration中并返回DefaultSqlSessionFactory对象
		 * 
		 * 	SqlSessionFactoryBuilder  ---> build(inputStream)  ->>XMLConfigBuilder(解析器) parser
		 * 
		 * 	-》》parser.parse()  ---》解析后会产生一个Configuration对象保存配置文件的属性 
		 * 
		 * 	---》解析mapper.xml的时候把mapper.xml中的每个元素解析出来并保存 在全局 配置中
		 * 	将增删改查标签的每一个标签每一个属性都解析出来 ，封装成一个MappedStatement
		 *  一个MappedStatement 代表一个增删改查的标签的详细信息
		 * 	Configuration保存了所有配置文件的信息 包括全局配置 和 sql映射
		 * 		每个 Mapper接口对应一个MapperProxyFactory;
		 * 
		 * ----》parser.parse()返回 Configuration
		 * 
		 * ----》 build(Configuration config) 
		 * 
		 * ----》》new DefaultSqlSessionFactory(config);	
		 * 
		 * 
		
		获取sqlSession对象:
			
			->>DefaultSqlSessionFactory.openSession()
			
			->>openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
						\
					获取信息 创建事务....
					Executor executor = configuration.newExecutor(tx, execType);
						根据Executor全局配置的类型 创建出
						executor = new SimpleExecutor(this, transaction);
							executor作用 是增删改查
							如果有二级缓存 创建一个CachingExecutor包装SimpleExecutor
							使用每一个拦截器 包装executor并返回
								executor = (Executor) interceptorChain.pluginAll(executor);
							
			->> return new DefaultSqlSession(configuration, executor, autoCommit);
					
	 获取接口的实现类对象:
		getMapper
			configuration.<T>getMapper(type, this);
				mapperRegistry.getMapper(type, sqlSession);
					final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);	
	 * 						 mapperProxyFactory.newInstance(sqlSession)
	 * 								MapperProxy<T> mapperProxy = new MapperProxy<T>(sqlSession, mapperInterface, methodCache);
	 * 										MapperProxy继承InvocationHandler
	 * 											Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
	 * 	
	 * 
	 * 
	 * 
	 * 
	 执行增删改查
 			mapper.getEmpById(2);
 				-->MapperProxy  Object invoke(Object proxy, Method method, Object[] args) 
 					final MapperMethod mapperMethod = cachedMapperMethod(method);
 					mapperMethod.execute(sqlSession, args);
 						先判断增删改查
 						包装参数是一个map或者直接返回
 					 Object param = method.convertArgsToSqlCommandParam(args);
          			result = sqlSession.selectOne(command.getName(), param);
          			 List<T> list = this.<T>selectList(statement, parameter);
				    if (list.size() == 1) {
				      return list.get(0);
 					 MappedStatement ms = configuration.getMappedStatement(statement);
      			    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
 						 MappedStatement ms = configuration.getMappedStatement(statement);
      				return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
 					 
 					 BoundSql:代表sql语句的详细信息
 					 BoundSql boundSql = ms.getBoundSql(parameter);
 					  CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
    					return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
    					
    				delegate就是SimpleExecutor
    				先查询二级缓存 没有则调用delegate
    				
 					delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
 					
 					delegate.<E> query先查询本地缓存 没有则查询数据库
 					
 					list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);


					查出以后会保存到本地缓存中
	 				localCache.putObject(key, EXECUTION_PLACEHOLDER);
				    try {
				      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
				    } finally {
				      localCache.removeObject(key);
				    }
				    localCache.putObject(key, list);
				    
				    四大对象的
				    StatementHandler:可以创建出Statement对象
				    	 @Override
					  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
					    Statement stmt = null;
					    try {
					      Configuration configuration = ms.getConfiguration();
					      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
					      stmt = prepareStatement(handler, ms.getStatementLog());
					      return handler.<E>query(stmt, resultHandler);
					    } finally {
					      closeStatement(stmt);
					    }
					  }
	 * 			创建出这个对象  PreparedStatementHandler
	 * 			使用拦截器包装 statementHandler
	 * 			statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
	 * 			
	 * 			创建 四大对象的 parameterHandler 进行预编译
	 * 
	 * 			在创建StatementHandler时候创建 都会通过interceptorChain.pluginAll包装一下这些对象
	 * 			this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);
    			this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);
	 * 			
	 * 			parameterHandler作用设置参数
	 * 					调用typehandler给sql语句设置参数
	 * 
	 * 			最终查出数据后使用resultSetHandler处理结果
	 * 
	 * 总结:
	 * 		查询流程:
	 * 			代理对象执行查询 - 》 使用defaltSqlSession -》 Executor ->
	 * 			创建statementHandler 用来处理sql语句预编译 设置参数等工作
	 * 				statementHandler 创建的时候创建 parameterHandler,resultSetHandler
	 * 				statementHandler设置参数的时候使用 parameterHandler(使用typeHandler设置参数)
	 * 				statementHandler使用他来 resultSetHandler处理结果的(使用typeHandler处理结果的)
	 * 			typeHandler在整个过程中进行数据库类型和javabean类型的映射
	 * 
	 * 	所有的顶层都是调用原生的jdbc操作的	
	 
	整个的总结:
		1.根据配置文件(全局,sql映射)初始化Configuration对象
		2.创建一个DefaultSqlSession对象，
		它里面包含Configuration对象以及Executor(根据全局的defaultExecutorType属性创建的)
		默认是SimpleExecutor
		3. 	defaultExecutorType.getMapper的时候拿到Mapper接口的MapperProxy
		4.MapperProxy中包含DefaultSqlSession
		5.执行增删该查方法
			1.调用DefaultSqlSession的增删该查(Executor)
			2.会创建一个statementhandler对象，同时也会创建出parameterHandler,resultSetHandler
			3.调用statementhandler的预编译参数以及设置参数值
				使用parameterHandler来给sql语句设置参数
			4.调用statementhandler的增删改查方法
			5.resultSetHandler封装结果
			
		注意:四大对象的作用
			每个四大对象创建的时候都有一个interceptorChain.pluginAll(target)包装一下这些对象
		
	
*************************************************************************************************************
MyBatis-插件开发
	• MyBatis在四大对象的创建过程中，都会有插件进行
	介入。插件可以利用动态代理机制一层层的包装目标
	对象，而实现在目标对象执行目标方法之前进行拦截
	的效果。
	
	• MyBatis 允许在已映射语句执行过程中的某一点进行
	拦截调用。
	
	• 默认情况下，MyBatis 允许使用插件来拦截的方法调
	 用包括：
	• Executor (update, query, flushStatements, commit, rollback, 
	 getTransaction, close, isClosed) 
	
	• ParameterHandler (getParameterObject, setParameters) 
	
	• ResultSetHandler (handleResultSets, handleOutputParameters) 
	
	• StatementHandler (prepare, parameterize, batch, update, query) 
		
		 
		
		
插件的编写步骤:
	  		插件开发步骤
			1.编写Interceptor的实现类
			2.使用@Intercepts注解完成插件签名
			3.将写好的插件注册到全局配置文件中 
			
多个插件的运行流程:
	多个插件就会产生多层代理
	创建动态代理的时候是按照插件配置顺序进行创建层层代理对象
	执行目标方法的时候,肯定就是逆向的顺序执行的,因为最大的代理对象时最后一个注册的插件包裹代理的
	
编写插件实例:
1.

/**
 * 完成插件签名
 * 	告诉MyBatis当前插件用来拦截哪个对象的那个方法
 * @author Administrator
 *
 */
/**
 * 完成插件签名
 * 	告诉MyBatis当前插件用来拦截哪个对象的那个方法
 * @author Administrator
 *
 */
@Intercepts(
		{
			@Signature( type=StatementHandler.class,
						method="parameterize",
						args=java.sql.Statement.class 
					)
		}
		)
public class MyFirstPlugin  implements Interceptor{

	public MyFirstPlugin() {
		// TODO Auto-generated constructor stub
	}
	
	/**
	 * 	intercept:拦截
	 * 		拦截目标对象的目标放行方法的执行
	 * 
	 */
	@Override
	public Object intercept(Invocation invocation) throws Throwable {
		// TODO Auto-generated method stub
		
		System.out.println("MyFirstPlugin ... intercept " + invocation.getTarget() );
		System.out.println("MyFirstPlugin ... intercept " + invocation.getMethod() );
		
		//动态改变sql运行的参数   以前查询的是2号员工 实际查询3号员工 偷梁换柱
		
		//经过分析StatementHandler ==> ParemeterHanler=>>parameterObject
		//拿到target的元数据
		Object target = invocation.getTarget();
		MetaObject metaObject = SystemMetaObject.forObject(target);
		Object value = metaObject.getValue("parameterHandler.parameterObject");
		System.out.println( "sql 语句用的参数  :"+ value);
		//修改完sql语句要用的参数
		metaObject.setValue("parameterHandler.parameterObject", 5);
		//执行目标方法
		Object proceed =  invocation.proceed();
		//返回执行后的返回值
		return proceed;
	}
	
	/**
	 * 	包装目标对象的:包装,为目标对象创建代理对象
	 * 
	 */
	@Override
	public Object plugin(Object target) {
		
		//我们可以借助Plugin.wrap方法来使用当前Interceptor包装目标对象
		
		Object obj = Plugin.wrap( target, this );
		System.out.println( "MyFirstPlugin   plugin : mybatis 将要包装的对象 " + target );
		//返回为当前target的动态代理
		return obj;
	}

	/**
	 * 	将插件注册时的Property属性设置进来
	 * 
	 */
	@Override
	public void setProperties(Properties properties) {
		// TODO Auto-generated method stub
		System.out.println( "插件的配置信息:" + properties );
	}

}


2.注册

 <plugins>
 	
 	<plugin interceptor="com.atguigu.mybatis.dao.MyFirstPlugin" >
 		<property name="username" value="root"/>
 		<property name="password" value="123456"/>
 	</plugin>
 
 </plugins>

*************************************************************************************************************
PageHelper 
	的使用：
	使用步骤
	
	• 1、导入相关包pagehelper-x.x.x.jar 和 jsqlparse0.9.5.jar。
	• 2、在MyBatis全局配置文件中配置分页插件
	• 3、使用PageHelper提供的方法进行分页
	• 4、可以使用更强大的PageInfo封装返回	
	
 	 <plugin interceptor="com.github.pagehelper.PageInterceptor">
        <property name="" value="value1"/>
	</plugin>
 

		public static void testPageHelper() throws IOException {
		String resource = "config/mybatis-config.xml";
		InputStream inputStream = Resources.getResourceAsStream(resource);
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
		
		SqlSession sqlSession = sqlSessionFactory.openSession();
		
		EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
	
		//第一种方法
		 Page<Employee> page = PageHelper.startPage(2,  30 );
		
		 List<Employee> emps = mapper.getEmps();
		
		 for( Employee e : emps ) {
			 System.out.println( e );
		 }
		 
//		 System.out.println( "当前页码:"+page.getPageNum());
//		 System.out.println( "总记录数:"+page.getTotal());
//		 System.out.println( "每页记录数:"+page.getPageSize());
//		 System.out.println( "共多少页:"+page.getPages() );
//	
		 //第二种更厉害的方式
		 
		 //PageInfo<Employee> pageInfo =  new PageInfo<Employee>(emps);
		 
		 //第二个参数是要联系显示几页
		 PageInfo<Employee> pageInfo =  new PageInfo<Employee>(emps , 5 );
		 
		 System.out.println( "当前页码:"+pageInfo.getPageNum());
		 System.out.println( "总记录数:"+pageInfo.getTotal());
		 System.out.println( "每页记录数:"+pageInfo.getPageSize());
		 System.out.println( "共多少页:"+pageInfo.getPages() );
		 System.out.println( "是否有下一页:"+pageInfo.isHasNextPage() );
		 System.out.println( "是否有下一页:"+pageInfo.isHasPreviousPage() );
		 System.out.println( "是否第一页:"+pageInfo.isIsFirstPage() );
		 System.out.println( "是否最后一页:"+pageInfo.isIsLastPage());
		 
		 int[] nums = pageInfo.getNavigatepageNums();
		 for( int i = 0 ; i < nums.length ; ++i  )
		 {
			 System.out.println( "联系显示的页码:"  + nums[i]);
		 }
		 sqlSession.commit();
	}
	

*************************************************************************************************************
mybatis 批量操作:
	批量操作
		• 默认的 openSession() 方法没有参数,它会创建有如下特性的
		– 会开启一个事务(也就是不自动提交)
		– 连接对象会从由活动环境配置的数据源实例得到。
		– 事务隔离级别将会使用驱动或数据源的默认设置。
		– 预处理语句不会被复用,也不会批量处理更新。
		• openSession 方法的 ExecutorType 类型的参数，枚举类型:
		– ExecutorType.SIMPLE: 这个执行器类型不做特殊的事情（这是默认装配
		的）。它为每个语句的执行创建一个新的预处理语句。
		– ExecutorType.REUSE: 这个执行器类型会复用预处理语句。
		– ExecutorType.BATCH: 这个执行器会批量执行所有更新语句
		
		• 批量操作我们是使用MyBatis提供的BatchExecutor进行的，
		他的底层就是通过jdbc攒sql的方式进行的。我们可以让他
		攒够一定数量后发给数据库一次。
		public void test01() {
			SqlSession openSession = build.openSession(ExecutorType.BATCH);
			UserDao mapper = openSession.getMapper(UserDao.class);
			long start = System.currentTimeMillis();
			for (int i = 0; i < 1000000; i++) {
			String name = UUID.randomUUID().toString().substring(0, 5);
			mapper.addUser(new User(null, name, 13));
		}
		openSession.commit();
		openSession.close();
		long end = System.currentTimeMillis();
		System.out.println("耗时时间："+(end-start));
		
		• 与Spring整合中，我们推荐，额外的配置一个可以专门用来执行批量操作的sqlSession
			<!--配置一个可以批量执行的sqlSession-->
			<bean id="" class="org.mybatis.spring.SqlSessionTemplate">
				<constructor-arg name="sqlSessionFactory" ref="sessionFactoryBean"></constructor-arg>
				<constructor-arg name="executorType" value="BATCH"></constructor-arg>
			</bean>
			
			用的时候只需要在service层注入一个
			@AutoWired
			SqlSession sqlSession 
				然后就是sqlsession.getMapper();....增删改查方法
				
							
		需要用到批量操作的时候，我们可以注入配置的这个批量
		SqlSession。通过他获取到mapper映射器进行操作。
		
		• 注意：
		• 1、批量操作是在session.commit()以后才发送sql语句给数
		据库进行执行的
		• 2、如果我们想让其提前执行，以方便后续可能的查询操作
		获取数据，我们可以使用sqlSession.flushStatements()方
		法，让其直接冲刷到数据库进行执行。
		
		
		public static void save() throws IOException {
		String resource = "config/mybatis-config.xml";
		InputStream inputStream = Resources.getResourceAsStream(resource);
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
		//
		SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);
		
		EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
		
		long start = System.currentTimeMillis();
		for (int i = 0; i < 10000; i++) {
			Employee e = new Employee();
			e.setLastName(UUID.randomUUID().toString().substring(0, 6));
			e.setEmail("zz@163.com");
			e.setGender("0");
			
			mapper.saveEmp(e);
		}
		//批量:(预编译sql一次 ==》设置参数===>1000 次 ===》执行一次成功
		//8739  每次都是设置参数的ExecutorType.BATCH
		//非批量:(预编译sql ==》设置参数=== 10000次>10001次
		//11876 每次都发送sqlExecutorType.SIMPLE
	
		sqlSession.commit();	
		System.out.println( System.currentTimeMillis() - start );
	}

*************************************************************************************************************
存储过程

	• 实际开发中，我们通常也会写一些存储过程，
		MyBatis也支持对存储过程的调用
		• 一个最简单的存储过程
		
		·delimiter $$
		create procedure test()
		begin
		select 'hello';
		end $$
		delimiter ;
		
		• 存储过程的调用
		
		1、select标签中statementType=“CALLABLE”
		
		2、标签体中调用语法：
		{call procedure_name(#{param1_info},#{param2_info})}
		存储过程-游标处理
		
		• MyBatis对存储过程的游标提供了一个JdbcType=CURSOR的支持，
		可以智能的把游标读取到的数据，映射到我们声明的结果集中
		
		• 调用实例：
			public class PageEmp {
			private int start;
			private int end;
			private int count;
			private List<Emp> emps;
			
			<environment id="oracle_dev">
			<transactionManager type="JDBC" />
			<dataSource type="POOLED">
			<property name="driver" value="${orcl.driver}" />
			<property name="url" value="${orcl.url}" />
			<property name="username" value="${orcl.username}" />
			<property name="password" value="${orcl.password}" />
			</dataSource>
			</environment>
			
			
			orcl.driver=oracle.jdbc.OracleDriver
			orcl.url=jdbc:oracle:thin:@localhost:1521:orcl
			orcl.username=scott
			orcl.password=123456
		
		public class PageEmp {
				private int start;
				private int end;
				private int count;
				private List<Emp> emps;


		<environment id="oracle_dev">
		<transactionManager type="JDBC" />
		<dataSource type="POOLED">
		<property name="driver" value="${orcl.driver}" />
		<property name="url" value="${orcl.url}" />
		<property name="username" value="${orcl.username}" />
		<property name="password" value="${orcl.password}" />
		</dataSource>
		</environment>
		
		<databaseIdProvider type="DB_VENDOR">
			<property name="MySQL" value="mysql"/>
			<property name="Oracle" value="oracle"/>
		</databaseIdProvider>
		
		
*************************************************************************************************************       
TypeHandler
	自定义typeHandler:
		
/**
 * 
 * 希望数据库保存的时状态吗的数值
 * 而不时默认的0,1
 * @author Administrator
 *
 */
public enum EmpStauts {

	LOGIN(100 ,"用户登录"),
	LOGOUT(200,"用户登出"),
	REMOVE(300,"用户不存在");
	
	private Integer code;
	private String msg;
	
	
	
	public Integer getCode() {
		return code;
	}



	public void setCode(Integer code) {
		this.code = code;
	}



	public String getMsg() {
		return msg;
	}



	public void setMsg(String msg) {
		this.msg = msg;
	}



	private EmpStauts( Integer code , String message ) {
		// TODO Auto-generated constructor stub
		this.code = code;
		this.msg = message;
	}
	
	
	public static EmpStauts getEmpStatusByCode( Integer code ) {
		
		switch (code) {
		case 100:
			
			return EmpStauts.LOGIN;
		case 200:
			
			return EmpStauts.LOGOUT;
		case 300:
		
		return EmpStauts.REMOVE;
			
		default:

			return null;
		}
		
	}
	
}
		
		<typeHandlers>
 		<!-- 配置自定义处理器 -->
 		<typeHandler handler="com.atguigu.mybatis.bean.MyEnumTypeHandler"
 		 javaType="com.atguigu.mybatis.bean.EmpStauts" ></typeHandler>
 		 <!-- 也可以在处理某个字段的时候告诉mybatis 用什么类型处理器
 		 
 		 	保存:在mapper文件中某个字段#{xxx , typeHandler=全类名}
 		 	查询:
		 	<resultMap type="xx" id="xx">
		 		<result column="empStatus" property="empStatus" typeHandler="xxx"/>
		 	</resultMap>
 		
 			注意:
 				如果在参数位置修改的TypeHandler,应该保证保存数据和查询数据的typeHandler一样的	
 		  -->
 		
 		 

 	</typeHandlers>	
	
	public class MyEnumTypeHandler implements TypeHandler<EmpStauts> {

	@Override
	public void setParameter(PreparedStatement ps, int i, EmpStauts parameter, JdbcType jdbcType) throws SQLException {
		// TODO Auto-generated method stub
		ps.setInt(i , parameter.getCode() );
	}

	@Override
	public EmpStauts getResult(ResultSet rs, String columnName) throws SQLException {
		
		String code = rs.getString(columnName);
		
		return EmpStauts.getEmpStatusByCode(Integer.parseInt(code));
	}

	@Override
	public EmpStauts getResult(ResultSet rs, int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public EmpStauts getResult(CallableStatement cs, int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

}
	
	
*************************************************************************************************************