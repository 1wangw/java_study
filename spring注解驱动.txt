spring注解驱动:

	配置方式:
	
		ApplicationContext  ctx =  new ClassPathXmlApplicationContext("classpath:beans.xml");		
		Person person = ctx.getBean("person" , Person.class );
		System.out.println( person );
	
		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:p="http://www.springframework.org/schema/p"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
			<bean id="person" class="com.atguigu.bean.Person" p:name="zhansan" p:age="18">
			</bean>
		</beans>
	
	
	注解方式:
		
		//注解的方式
		
		ApplicationContext  ctx = 	new AnnotationConfigApplicationContext(MainConfig.class);
		Person person = ctx.getBean("person" , Person.class );
	//	System.out.println( person );
		
		String[] namesForType = ctx.getBeanNamesForType(Person.class);
		
		for (int i = 0; i < namesForType.length; i++) {
			
			System.out.println( namesForType[i] );
		}
		
		
		
		
		/**
		 *配置类等同于以前的配置文件
		 * 
		 * @author Administrator
		 *
		 */
		@ComponentScan(value="com.atguigu" ,includeFilters={
		//		@Filter(type=FilterType.ANNOTATION , classes={Controller.class}),
		//		@Filter(type=FilterType.ASSIGNABLE_TYPE, classes={BookService.class}),
				@Filter(type=FilterType.CUSTOM, classes={MyTypeFilter.class})	
		},useDefaultFilters=false
				)
		/*
		 * @ComponentScan value: 指定要扫描的包  										
		 *  excludeFilters = Filter[]:指定扫描的的时候按照什么规则排除那些组件
		 *  excludeFilters={
			@Filter(type=FilterType.ANNOTATION , classes={Controller.class,Service.class})  },
			
			includeFilters={
				@Filter(type=FilterType.ANNOTATION , classes={Controller.class,Service.class}) 	
			},useDefaultFilters=false
			
			includeFilters = Filter[]:指定扫描的时候只需要扫描那些包
			excludeFilters = Filter[]:指定扫描的时候按照什么规则排除那些组件
			
		FilterType.ANNOTATION :	按照注解
		FilterType.ASSIGNABLE_TYPE：	按照指定的类型
			@Filter(type=FilterType.ASSIGNABLE_TYPE, classes={BookService.class})
		FilterType.ASPECTJ:
		FilterType.REGEX:	
		FilterType.CUSTOM:使用自定义的规则
					FilterType.REGEX:必须是TypeFilter的实现类
		 */

		@Configurable //告诉spring这是一个配置类  
		public class MainConfig {

			@Bean( value="person" ) //给容器中注册一个bean实例,相比于配置文件class属性: 类型为返回值的类型   id:默认是方法名字做为id
			public Person person01() {
				
				return new Person( "lisi" , 20 );
			}
		}
		
		
		public class MyTypeFilter implements TypeFilter {

		public MyTypeFilter() {
			// TODO Auto-generated constructor stub
		}
		
		/**
		 * metadataReader:读取到的当前正在扫描的类的信息
		 * metadataReaderFactory:可以获取到其他任何类信息的
		 * 
		 */
		@Override
		public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
				throws IOException {
			
			//获取当前类注解的信息
			AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
			//获取当前正在扫描的的类的信息
			ClassMetadata classMetadata = metadataReader.getClassMetadata();
			//获取当前正在扫描的的类的资源信息(类的路径 )
			Resource resource = metadataReader.getResource();
			
		   String className =  classMetadata.getClassName();
			
		   System.out.println( "->>>  " + className  );
		   
		   if ( className.contains("er") ) {
			   
			   return true;
		   }
			return false;
		}

	}
	
	
	
@Scope注解:

	/**
	 *默认是单实例的:
	 *	@Scope  调整作用域的
	 * /**
	 * Specifies the name of the scope to use for the annotated component/bean.
	 * <p>Defaults to an empty string ({@code ""}) which implies
	 * {@link ConfigurableBeanFactory#SCOPE_SINGLETON SCOPE_SINGLETON}.
	 *   prototype  多实例的  ioc容器启动的时候并不会创建这个对象 
	 *   			 直到用户每次获取对象的时候才执行
	 *   singleton	  单实例的  默认值 默认在单实例情况下,ioc容器启动会调用方法创建对线放到ioc容器中
	 *   			以后每次获取都是直接从容器(map.get())中拿
	 *  request  同一个请求创建一个实例
	 * 	session	  同一个会话创建一个实例
	 */
	
	@Bean("person")
	@Scope("prototype")
	public Person person() {
		System.out.println( "给容器中添加bean");
		return new Person("zhansan", 15);
	}
	
懒加载:
	单实例bean默认在容器启动的时候创建对象,
	懒加载:容器启动不创建对象  在第一次使用获取bean的时候创建对象,并初始化;
	@Lazy

	@Configurable
	public class MainConfig2 {


	
		@Bean("person")
		@Scope("singleton")
		@Lazy(true)
		public Person person() {
			System.out.println( "给容器中添加bean");
			return new Person("zhansan", 15);
		}
    }
	

@Condtional

	 可以标注在类上也可以标注在方法上
	 标注在类上:满足当前条件,这个类中配置的所有bean注册才能生效  类中组建统一设置
		
	/**
	 * @Condtional:springboot底层大量使用的注解
	 * 	作用:按照一定条件进行判断,满足条件给容器中注册bean
	 * 
	 * 需求:如果系统是win 则给容器中注册bill
	 * 	   如果系统是linux 则给容器中注册 linux 
	 * 
	 *  @Condtional({Condition})
	 */
	@Bean
	@Conditional({  WindowsCondtional.class })
	public Person person01(){
		
		return new Person( "bill", 60 );
	}
	
	@Bean
	@Conditional({  LinuxCondtional.class })
	public Person person02(){
		
		return new Person( "linux", 48 );
	}
	
	
	
	//判断是否是linux
	public class LinuxCondtional implements Condition {

			public LinuxCondtional() {
			}
			
			/**
			 * ConditionContext:判断条件可以使用的上下文环境
			 * 
			 * AnnotatedTypeMetadata:当前标注了Condition的注解信息
			 * 		
			 */
			@Override
			public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
				
				//判断是否是linux 系统
				
				//1.能获取IOC使用的beanfactory
				ConfigurableListableBeanFactory beanFactory =  context.getBeanFactory();
				
				//获取类加载器
				ClassLoader classLoader = context.getClassLoader();
				
				//获取当前环境信息
				Environment environment = context.getEnvironment();
				
				//获取bean定义的注册类
				BeanDefinitionRegistry beanDefinitionRegistry = context.getRegistry();
				
				String property = environment.getProperty("os.name");
				
				if ( property.contains("linux")) {
					
					return true;
				}
				
				//		//判断容器中bean的注册情况
//			if( beanDefinitionRegistry.containsBeanDefinition(beanName)) {
//			
//					 return true;
//			}
				
				return false;
			}

	}
	
	
	
	@Test
	public void test03() {
		
		@SuppressWarnings("resource")
		ApplicationContext ctx = new AnnotationConfigApplicationContext( MainConfig2.class );
		
		ConfigurableEnvironment environment = (ConfigurableEnvironment) ctx.getEnvironment();
		//动态获取环境变量的值
		String property = environment.getProperty("os.name");
		System.out.println( property  );
		
		String[] names = ctx.getBeanNamesForType(Person.class);
		for (int i = 0; i < names.length; i++) {
			
			System.out.println( names[i] );
		}
		
		Map<String,Person >  persons  = ctx.getBeansOfType(Person.class);
		System.out.println( persons );
	}
	
小结:
	给容器中注入组件的方式:
		1.包扫描+组件标注注解(@Controller @Service @Repository @Component)[自己写的类]
		2.使用@Bean[导入的第三方包]
		3.@Import[快速给容器中导入组件]
			
			1.@Import(要导入到容器中的组件):容器会自动注册这个组件,id默认是全类名
			
				@Import(Color.class)
			//导入组件:id默认是组建的全类名
			public class MainConfig2 { }
			
			2. ImportSelector:返回需要导入组件的全类名的数组 
			
			//自定义逻辑返回需要导入组件的全类名数组
			public class MyImportSelector implements ImportSelector{

				public MyImportSelector() {
					// TODO Auto-generated constructor stub
				}
				
				/**
				 * 返回值:要导入到容器中的组件的全类名数组
				 * AnnotationMetadata:当前标注了@Import注解类的所有注解信息
				 */
				@Override
				public String[] selectImports(AnnotationMetadata importingClassMetadata) {
					
					
					
					return null;
				}

			}
			
				@Configurable
				@Import({Color.class,MyImportSelector.class})
				//导入组件:id默认是组建的全类名

				public class MainConfig2 {
				}
				
				
			3.	ImportBeanDefinitionRegistrar 
			
				
			public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

			public MyImportBeanDefinitionRegistrar() {
				// TODO Auto-generated constructor stub
			}
			
			/**
			 * importingClassMetadata:当前类的注解信息
			 * registry:BeanDefinition定义的注册类
			 * 			把所有需要添加的容器中的bean：调用 BeanDefinitionRegistry.registerBeanDefinition
			 * 			手工注册进来
			 */
			@Override
			public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
				
				//指定bean的名称
				RootBeanDefinition  rootBeanDefinition = new RootBeanDefinition(RainBow.class);
				registry.registerBeanDefinition("rainBox ", rootBeanDefinition );
			}

			}
			@Configurable
			@Import({Color.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})
			//导入组件:id默认是组建的全类名

			public class MainConfig2 {
			}
**********************************************************************

